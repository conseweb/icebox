// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: icebox.proto

#ifndef PROTOBUF_icebox_2eproto__INCLUDED
#define PROTOBUF_icebox_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
// @@protoc_insertion_point(includes)
class AddCoinReply;
class AddCoinReplyDefaultTypeInternal;
extern AddCoinReplyDefaultTypeInternal _AddCoinReply_default_instance_;
class AddCoinRequest;
class AddCoinRequestDefaultTypeInternal;
extern AddCoinRequestDefaultTypeInternal _AddCoinRequest_default_instance_;
class AddSecretReply;
class AddSecretReplyDefaultTypeInternal;
extern AddSecretReplyDefaultTypeInternal _AddSecretReply_default_instance_;
class AddSecretRequest;
class AddSecretRequestDefaultTypeInternal;
extern AddSecretRequestDefaultTypeInternal _AddSecretRequest_default_instance_;
class Address;
class AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class CheckReply;
class CheckReplyDefaultTypeInternal;
extern CheckReplyDefaultTypeInternal _CheckReply_default_instance_;
class CheckRequest;
class CheckRequestDefaultTypeInternal;
extern CheckRequestDefaultTypeInternal _CheckRequest_default_instance_;
class ConversationReply;
class ConversationReplyDefaultTypeInternal;
extern ConversationReplyDefaultTypeInternal _ConversationReply_default_instance_;
class ConversationRequest;
class ConversationRequestDefaultTypeInternal;
extern ConversationRequestDefaultTypeInternal _ConversationRequest_default_instance_;
class CreateAddressReply;
class CreateAddressReplyDefaultTypeInternal;
extern CreateAddressReplyDefaultTypeInternal _CreateAddressReply_default_instance_;
class CreateAddressRequest;
class CreateAddressRequestDefaultTypeInternal;
extern CreateAddressRequestDefaultTypeInternal _CreateAddressRequest_default_instance_;
class CreateSecretReply;
class CreateSecretReplyDefaultTypeInternal;
extern CreateSecretReplyDefaultTypeInternal _CreateSecretReply_default_instance_;
class CreateSecretRequest;
class CreateSecretRequestDefaultTypeInternal;
extern CreateSecretRequestDefaultTypeInternal _CreateSecretRequest_default_instance_;
class DeleteAddressReply;
class DeleteAddressReplyDefaultTypeInternal;
extern DeleteAddressReplyDefaultTypeInternal _DeleteAddressReply_default_instance_;
class DeleteAddressRequest;
class DeleteAddressRequestDefaultTypeInternal;
extern DeleteAddressRequestDefaultTypeInternal _DeleteAddressRequest_default_instance_;
class DeleteSecretReply;
class DeleteSecretReplyDefaultTypeInternal;
extern DeleteSecretReplyDefaultTypeInternal _DeleteSecretReply_default_instance_;
class DeleteSecretRequest;
class DeleteSecretRequestDefaultTypeInternal;
extern DeleteSecretRequestDefaultTypeInternal _DeleteSecretRequest_default_instance_;
class DispMsgReply;
class DispMsgReplyDefaultTypeInternal;
extern DispMsgReplyDefaultTypeInternal _DispMsgReply_default_instance_;
class DispMsgRequest;
class DispMsgRequestDefaultTypeInternal;
extern DispMsgRequestDefaultTypeInternal _DispMsgRequest_default_instance_;
class EndReply;
class EndReplyDefaultTypeInternal;
extern EndReplyDefaultTypeInternal _EndReply_default_instance_;
class EndRequest;
class EndRequestDefaultTypeInternal;
extern EndRequestDefaultTypeInternal _EndRequest_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class GetAddressReply;
class GetAddressReplyDefaultTypeInternal;
extern GetAddressReplyDefaultTypeInternal _GetAddressReply_default_instance_;
class GetAddressRequest;
class GetAddressRequestDefaultTypeInternal;
extern GetAddressRequestDefaultTypeInternal _GetAddressRequest_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class HiReply;
class HiReplyDefaultTypeInternal;
extern HiReplyDefaultTypeInternal _HiReply_default_instance_;
class HiRequest;
class HiRequestDefaultTypeInternal;
extern HiRequestDefaultTypeInternal _HiRequest_default_instance_;
class IceboxMessage;
class IceboxMessageDefaultTypeInternal;
extern IceboxMessageDefaultTypeInternal _IceboxMessage_default_instance_;
class IceboxMessage_Header;
class IceboxMessage_HeaderDefaultTypeInternal;
extern IceboxMessage_HeaderDefaultTypeInternal _IceboxMessage_Header_default_instance_;
class InitReply;
class InitReplyDefaultTypeInternal;
extern InitReplyDefaultTypeInternal _InitReply_default_instance_;
class InitRequest;
class InitRequestDefaultTypeInternal;
extern InitRequestDefaultTypeInternal _InitRequest_default_instance_;
class ListAddressReply;
class ListAddressReplyDefaultTypeInternal;
extern ListAddressReplyDefaultTypeInternal _ListAddressReply_default_instance_;
class ListAddressRequest;
class ListAddressRequestDefaultTypeInternal;
extern ListAddressRequestDefaultTypeInternal _ListAddressRequest_default_instance_;
class ListCoinReply;
class ListCoinReplyDefaultTypeInternal;
extern ListCoinReplyDefaultTypeInternal _ListCoinReply_default_instance_;
class ListCoinRequest;
class ListCoinRequestDefaultTypeInternal;
extern ListCoinRequestDefaultTypeInternal _ListCoinRequest_default_instance_;
class ListSecretReply;
class ListSecretReplyDefaultTypeInternal;
extern ListSecretReplyDefaultTypeInternal _ListSecretReply_default_instance_;
class ListSecretRequest;
class ListSecretRequestDefaultTypeInternal;
extern ListSecretRequestDefaultTypeInternal _ListSecretRequest_default_instance_;
class NegotiateReply;
class NegotiateReplyDefaultTypeInternal;
extern NegotiateReplyDefaultTypeInternal _NegotiateReply_default_instance_;
class NegotiateRequest;
class NegotiateRequestDefaultTypeInternal;
extern NegotiateRequestDefaultTypeInternal _NegotiateRequest_default_instance_;
class PingReply;
class PingReplyDefaultTypeInternal;
extern PingReplyDefaultTypeInternal _PingReply_default_instance_;
class PingRequest;
class PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class RemoveCoinReply;
class RemoveCoinReplyDefaultTypeInternal;
extern RemoveCoinReplyDefaultTypeInternal _RemoveCoinReply_default_instance_;
class RemoveCoinRequest;
class RemoveCoinRequestDefaultTypeInternal;
extern RemoveCoinRequestDefaultTypeInternal _RemoveCoinRequest_default_instance_;
class ReplyHeader;
class ReplyHeaderDefaultTypeInternal;
extern ReplyHeaderDefaultTypeInternal _ReplyHeader_default_instance_;
class ResetReply;
class ResetReplyDefaultTypeInternal;
extern ResetReplyDefaultTypeInternal _ResetReply_default_instance_;
class ResetRequest;
class ResetRequestDefaultTypeInternal;
extern ResetRequestDefaultTypeInternal _ResetRequest_default_instance_;
class Secret;
class SecretDefaultTypeInternal;
extern SecretDefaultTypeInternal _Secret_default_instance_;
class SignMsgReply;
class SignMsgReplyDefaultTypeInternal;
extern SignMsgReplyDefaultTypeInternal _SignMsgReply_default_instance_;
class SignMsgRequest;
class SignMsgRequestDefaultTypeInternal;
extern SignMsgRequestDefaultTypeInternal _SignMsgRequest_default_instance_;
class SignTxReply;
class SignTxReplyDefaultTypeInternal;
extern SignTxReplyDefaultTypeInternal _SignTxReply_default_instance_;
class SignTxRequest;
class SignTxRequestDefaultTypeInternal;
extern SignTxRequestDefaultTypeInternal _SignTxRequest_default_instance_;
class StartReply;
class StartReplyDefaultTypeInternal;
extern StartReplyDefaultTypeInternal _StartReply_default_instance_;
class StartRequest;
class StartRequestDefaultTypeInternal;
extern StartRequestDefaultTypeInternal _StartRequest_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;

namespace protobuf_icebox_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_icebox_2eproto

enum IceboxMessage_Type {
  IceboxMessage_Type_UNDEFINED = 0,
  IceboxMessage_Type_ERROR = 1,
  IceboxMessage_Type_HELLO = 2,
  IceboxMessage_Type_NEGOTIATE = 3,
  IceboxMessage_Type_START = 4,
  IceboxMessage_Type_END = 5,
  IceboxMessage_Type_CHECK = 6,
  IceboxMessage_Type_INIT = 7,
  IceboxMessage_Type_PING = 8,
  IceboxMessage_Type_RESET = 9,
  IceboxMessage_Type_ADD_COIN = 10,
  IceboxMessage_Type_CREATE_ADDRESS = 11,
  IceboxMessage_Type_CREATE_SECRET = 12,
  IceboxMessage_Type_LIST_COIN = 13,
  IceboxMessage_Type_LIST_ADDRESS = 14,
  IceboxMessage_Type_LIST_SECRET = 15,
  IceboxMessage_Type_SIGN_TX = 16,
  IceboxMessage_Type_REMOVE_COIN = 17,
  IceboxMessage_Type_DELETE_ADDRESS = 18,
  IceboxMessage_Type_DELETE_SECRET = 19,
  IceboxMessage_Type_GET_ADDRESS = 20,
  IceboxMessage_Type_GET_SECRET = 21,
  IceboxMessage_Type_SIGN_MSG = 22,
  IceboxMessage_Type_DISP_MSG = 23
};
bool IceboxMessage_Type_IsValid(int value);
const IceboxMessage_Type IceboxMessage_Type_Type_MIN = IceboxMessage_Type_UNDEFINED;
const IceboxMessage_Type IceboxMessage_Type_Type_MAX = IceboxMessage_Type_DISP_MSG;
const int IceboxMessage_Type_Type_ARRAYSIZE = IceboxMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* IceboxMessage_Type_descriptor();
inline const ::std::string& IceboxMessage_Type_Name(IceboxMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    IceboxMessage_Type_descriptor(), value);
}
inline bool IceboxMessage_Type_Parse(
    const ::std::string& name, IceboxMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IceboxMessage_Type>(
    IceboxMessage_Type_descriptor(), name, value);
}
// ===================================================================

class Timestamp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const PROTOBUF_FINAL { return New(NULL); }

  Timestamp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 seconds = 1;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::int64 seconds() const;
  void set_seconds(::google::protobuf::int64 value);

  // required int32 nanos = 2;
  bool has_nanos() const;
  void clear_nanos();
  static const int kNanosFieldNumber = 2;
  ::google::protobuf::int32 nanos() const;
  void set_nanos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Timestamp)
 private:
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_nanos();
  void clear_has_nanos();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 seconds_;
  ::google::protobuf::int32 nanos_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IceboxMessage_Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IceboxMessage.Header) */ {
 public:
  IceboxMessage_Header();
  virtual ~IceboxMessage_Header();

  IceboxMessage_Header(const IceboxMessage_Header& from);

  inline IceboxMessage_Header& operator=(const IceboxMessage_Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IceboxMessage_Header(IceboxMessage_Header&& from) noexcept
    : IceboxMessage_Header() {
    *this = ::std::move(from);
  }

  inline IceboxMessage_Header& operator=(IceboxMessage_Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IceboxMessage_Header& default_instance();

  static inline const IceboxMessage_Header* internal_default_instance() {
    return reinterpret_cast<const IceboxMessage_Header*>(
               &_IceboxMessage_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(IceboxMessage_Header* other);
  friend void swap(IceboxMessage_Header& a, IceboxMessage_Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IceboxMessage_Header* New() const PROTOBUF_FINAL { return New(NULL); }

  IceboxMessage_Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IceboxMessage_Header& from);
  void MergeFrom(const IceboxMessage_Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IceboxMessage_Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::Timestamp& timestamp() const;
  ::Timestamp* mutable_timestamp();
  ::Timestamp* release_timestamp();
  void set_allocated_timestamp(::Timestamp* timestamp);

  // required .IceboxMessage.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::IceboxMessage_Type type() const;
  void set_type(::IceboxMessage_Type value);

  // required uint32 session_id = 4;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // required uint32 version = 1 [default = 1];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IceboxMessage.Header)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_type();
  void clear_has_type();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_session_id();
  void clear_has_session_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Timestamp* timestamp_;
  int type_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 version_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IceboxMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IceboxMessage) */ {
 public:
  IceboxMessage();
  virtual ~IceboxMessage();

  IceboxMessage(const IceboxMessage& from);

  inline IceboxMessage& operator=(const IceboxMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IceboxMessage(IceboxMessage&& from) noexcept
    : IceboxMessage() {
    *this = ::std::move(from);
  }

  inline IceboxMessage& operator=(IceboxMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IceboxMessage& default_instance();

  static inline const IceboxMessage* internal_default_instance() {
    return reinterpret_cast<const IceboxMessage*>(
               &_IceboxMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(IceboxMessage* other);
  friend void swap(IceboxMessage& a, IceboxMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IceboxMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  IceboxMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IceboxMessage& from);
  void MergeFrom(const IceboxMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IceboxMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef IceboxMessage_Header Header;

  typedef IceboxMessage_Type Type;
  static const Type UNDEFINED =
    IceboxMessage_Type_UNDEFINED;
  static const Type ERROR =
    IceboxMessage_Type_ERROR;
  static const Type HELLO =
    IceboxMessage_Type_HELLO;
  static const Type NEGOTIATE =
    IceboxMessage_Type_NEGOTIATE;
  static const Type START =
    IceboxMessage_Type_START;
  static const Type END =
    IceboxMessage_Type_END;
  static const Type CHECK =
    IceboxMessage_Type_CHECK;
  static const Type INIT =
    IceboxMessage_Type_INIT;
  static const Type PING =
    IceboxMessage_Type_PING;
  static const Type RESET =
    IceboxMessage_Type_RESET;
  static const Type ADD_COIN =
    IceboxMessage_Type_ADD_COIN;
  static const Type CREATE_ADDRESS =
    IceboxMessage_Type_CREATE_ADDRESS;
  static const Type CREATE_SECRET =
    IceboxMessage_Type_CREATE_SECRET;
  static const Type LIST_COIN =
    IceboxMessage_Type_LIST_COIN;
  static const Type LIST_ADDRESS =
    IceboxMessage_Type_LIST_ADDRESS;
  static const Type LIST_SECRET =
    IceboxMessage_Type_LIST_SECRET;
  static const Type SIGN_TX =
    IceboxMessage_Type_SIGN_TX;
  static const Type REMOVE_COIN =
    IceboxMessage_Type_REMOVE_COIN;
  static const Type DELETE_ADDRESS =
    IceboxMessage_Type_DELETE_ADDRESS;
  static const Type DELETE_SECRET =
    IceboxMessage_Type_DELETE_SECRET;
  static const Type GET_ADDRESS =
    IceboxMessage_Type_GET_ADDRESS;
  static const Type GET_SECRET =
    IceboxMessage_Type_GET_SECRET;
  static const Type SIGN_MSG =
    IceboxMessage_Type_SIGN_MSG;
  static const Type DISP_MSG =
    IceboxMessage_Type_DISP_MSG;
  static inline bool Type_IsValid(int value) {
    return IceboxMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    IceboxMessage_Type_Type_MIN;
  static const Type Type_MAX =
    IceboxMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    IceboxMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return IceboxMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return IceboxMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return IceboxMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes payload = 2;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // required bytes signature = 3;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 3;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // required .IceboxMessage.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::IceboxMessage_Header& header() const;
  ::IceboxMessage_Header* mutable_header();
  ::IceboxMessage_Header* release_header();
  void set_allocated_header(::IceboxMessage_Header* header);

  // @@protoc_insertion_point(class_scope:IceboxMessage)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_payload();
  void clear_has_payload();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::IceboxMessage_Header* header_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2 [(.nanopb) = {
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required int32 code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Error)
 private:
  void set_has_code();
  void clear_has_code();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 code_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sn = 2;
  bool has_sn() const;
  void clear_sn();
  static const int kSnFieldNumber = 2;
  ::google::protobuf::uint32 sn() const;
  void set_sn(::google::protobuf::uint32 value);

  // required uint32 ver = 1 [default = 1];
  bool has_ver() const;
  void clear_ver();
  static const int kVerFieldNumber = 1;
  ::google::protobuf::uint32 ver() const;
  void set_ver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Header)
 private:
  void set_has_ver();
  void clear_has_ver();
  void set_has_sn();
  void clear_has_sn();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 sn_;
  ::google::protobuf::uint32 ver_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReplyHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReplyHeader) */ {
 public:
  ReplyHeader();
  virtual ~ReplyHeader();

  ReplyHeader(const ReplyHeader& from);

  inline ReplyHeader& operator=(const ReplyHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplyHeader(ReplyHeader&& from) noexcept
    : ReplyHeader() {
    *this = ::std::move(from);
  }

  inline ReplyHeader& operator=(ReplyHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyHeader& default_instance();

  static inline const ReplyHeader* internal_default_instance() {
    return reinterpret_cast<const ReplyHeader*>(
               &_ReplyHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ReplyHeader* other);
  friend void swap(ReplyHeader& a, ReplyHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplyHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ReplyHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReplyHeader& from);
  void MergeFrom(const ReplyHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReplyHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 4 [(.nanopb) = {
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required uint32 sn = 2;
  bool has_sn() const;
  void clear_sn();
  static const int kSnFieldNumber = 2;
  ::google::protobuf::uint32 sn() const;
  void set_sn(::google::protobuf::uint32 value);

  // required uint32 code = 3;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // required uint32 ver = 1 [default = 1];
  bool has_ver() const;
  void clear_ver();
  static const int kVerFieldNumber = 1;
  ::google::protobuf::uint32 ver() const;
  void set_ver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ReplyHeader)
 private:
  void set_has_ver();
  void clear_has_ver();
  void set_has_sn();
  void clear_has_sn();
  void set_has_code();
  void clear_has_code();
  void set_has_message();
  void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 sn_;
  ::google::protobuf::uint32 code_;
  ::google::protobuf::uint32 ver_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HiRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HiRequest) */ {
 public:
  HiRequest();
  virtual ~HiRequest();

  HiRequest(const HiRequest& from);

  inline HiRequest& operator=(const HiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HiRequest(HiRequest&& from) noexcept
    : HiRequest() {
    *this = ::std::move(from);
  }

  inline HiRequest& operator=(HiRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HiRequest& default_instance();

  static inline const HiRequest* internal_default_instance() {
    return reinterpret_cast<const HiRequest*>(
               &_HiRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(HiRequest* other);
  friend void swap(HiRequest& a, HiRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HiRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  HiRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HiRequest& from);
  void MergeFrom(const HiRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HiRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 magicA = 2;
  bool has_magica() const;
  void clear_magica();
  static const int kMagicAFieldNumber = 2;
  ::google::protobuf::int64 magica() const;
  void set_magica(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:HiRequest)
 private:
  void set_has_magica();
  void clear_has_magica();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 magica_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HiReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HiReply) */ {
 public:
  HiReply();
  virtual ~HiReply();

  HiReply(const HiReply& from);

  inline HiReply& operator=(const HiReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HiReply(HiReply&& from) noexcept
    : HiReply() {
    *this = ::std::move(from);
  }

  inline HiReply& operator=(HiReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HiReply& default_instance();

  static inline const HiReply* internal_default_instance() {
    return reinterpret_cast<const HiReply*>(
               &_HiReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(HiReply* other);
  friend void swap(HiReply& a, HiReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HiReply* New() const PROTOBUF_FINAL { return New(NULL); }

  HiReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HiReply& from);
  void MergeFrom(const HiReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HiReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 magicB = 2;
  bool has_magicb() const;
  void clear_magicb();
  static const int kMagicBFieldNumber = 2;
  ::google::protobuf::int64 magicb() const;
  void set_magicb(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:HiReply)
 private:
  void set_has_magicb();
  void clear_has_magicb();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 magicb_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NegotiateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NegotiateRequest) */ {
 public:
  NegotiateRequest();
  virtual ~NegotiateRequest();

  NegotiateRequest(const NegotiateRequest& from);

  inline NegotiateRequest& operator=(const NegotiateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NegotiateRequest(NegotiateRequest&& from) noexcept
    : NegotiateRequest() {
    *this = ::std::move(from);
  }

  inline NegotiateRequest& operator=(NegotiateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NegotiateRequest& default_instance();

  static inline const NegotiateRequest* internal_default_instance() {
    return reinterpret_cast<const NegotiateRequest*>(
               &_NegotiateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(NegotiateRequest* other);
  friend void swap(NegotiateRequest& a, NegotiateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NegotiateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NegotiateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NegotiateRequest& from);
  void MergeFrom(const NegotiateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NegotiateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keyA = 2;
  bool has_keya() const;
  void clear_keya();
  static const int kKeyAFieldNumber = 2;
  const ::std::string& keya() const;
  void set_keya(const ::std::string& value);
  #if LANG_CXX11
  void set_keya(::std::string&& value);
  #endif
  void set_keya(const char* value);
  void set_keya(const char* value, size_t size);
  ::std::string* mutable_keya();
  ::std::string* release_keya();
  void set_allocated_keya(::std::string* keya);

  // required string hash = 3;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 3;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:NegotiateRequest)
 private:
  void set_has_keya();
  void clear_has_keya();
  void set_has_hash();
  void clear_has_hash();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr keya_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NegotiateReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NegotiateReply) */ {
 public:
  NegotiateReply();
  virtual ~NegotiateReply();

  NegotiateReply(const NegotiateReply& from);

  inline NegotiateReply& operator=(const NegotiateReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NegotiateReply(NegotiateReply&& from) noexcept
    : NegotiateReply() {
    *this = ::std::move(from);
  }

  inline NegotiateReply& operator=(NegotiateReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NegotiateReply& default_instance();

  static inline const NegotiateReply* internal_default_instance() {
    return reinterpret_cast<const NegotiateReply*>(
               &_NegotiateReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(NegotiateReply* other);
  friend void swap(NegotiateReply& a, NegotiateReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NegotiateReply* New() const PROTOBUF_FINAL { return New(NULL); }

  NegotiateReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NegotiateReply& from);
  void MergeFrom(const NegotiateReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NegotiateReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keyB = 2;
  bool has_keyb() const;
  void clear_keyb();
  static const int kKeyBFieldNumber = 2;
  const ::std::string& keyb() const;
  void set_keyb(const ::std::string& value);
  #if LANG_CXX11
  void set_keyb(::std::string&& value);
  #endif
  void set_keyb(const char* value);
  void set_keyb(const char* value, size_t size);
  ::std::string* mutable_keyb();
  ::std::string* release_keyb();
  void set_allocated_keyb(::std::string* keyb);

  // required string hash = 3;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 3;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:NegotiateReply)
 private:
  void set_has_keyb();
  void clear_has_keyb();
  void set_has_hash();
  void clear_has_hash();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr keyb_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StartRequest) */ {
 public:
  StartRequest();
  virtual ~StartRequest();

  StartRequest(const StartRequest& from);

  inline StartRequest& operator=(const StartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartRequest(StartRequest&& from) noexcept
    : StartRequest() {
    *this = ::std::move(from);
  }

  inline StartRequest& operator=(StartRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartRequest& default_instance();

  static inline const StartRequest* internal_default_instance() {
    return reinterpret_cast<const StartRequest*>(
               &_StartRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(StartRequest* other);
  friend void swap(StartRequest& a, StartRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StartRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StartRequest& from);
  void MergeFrom(const StartRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StartRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:StartRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StartReply) */ {
 public:
  StartReply();
  virtual ~StartReply();

  StartReply(const StartReply& from);

  inline StartReply& operator=(const StartReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartReply(StartReply&& from) noexcept
    : StartReply() {
    *this = ::std::move(from);
  }

  inline StartReply& operator=(StartReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartReply& default_instance();

  static inline const StartReply* internal_default_instance() {
    return reinterpret_cast<const StartReply*>(
               &_StartReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(StartReply* other);
  friend void swap(StartReply& a, StartReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartReply* New() const PROTOBUF_FINAL { return New(NULL); }

  StartReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StartReply& from);
  void MergeFrom(const StartReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StartReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:StartReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConversationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ConversationRequest) */ {
 public:
  ConversationRequest();
  virtual ~ConversationRequest();

  ConversationRequest(const ConversationRequest& from);

  inline ConversationRequest& operator=(const ConversationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConversationRequest(ConversationRequest&& from) noexcept
    : ConversationRequest() {
    *this = ::std::move(from);
  }

  inline ConversationRequest& operator=(ConversationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConversationRequest& default_instance();

  static inline const ConversationRequest* internal_default_instance() {
    return reinterpret_cast<const ConversationRequest*>(
               &_ConversationRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ConversationRequest* other);
  friend void swap(ConversationRequest& a, ConversationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConversationRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ConversationRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConversationRequest& from);
  void MergeFrom(const ConversationRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConversationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes content = 4;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 4;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // required bytes signature = 5;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // required uint32 session_id = 2;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // required uint32 message_id = 3;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  ::google::protobuf::uint32 message_id() const;
  void set_message_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ConversationRequest)
 private:
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_message_id();
  void clear_has_message_id();
  void set_has_content();
  void clear_has_content();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 message_id_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConversationReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ConversationReply) */ {
 public:
  ConversationReply();
  virtual ~ConversationReply();

  ConversationReply(const ConversationReply& from);

  inline ConversationReply& operator=(const ConversationReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConversationReply(ConversationReply&& from) noexcept
    : ConversationReply() {
    *this = ::std::move(from);
  }

  inline ConversationReply& operator=(ConversationReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConversationReply& default_instance();

  static inline const ConversationReply* internal_default_instance() {
    return reinterpret_cast<const ConversationReply*>(
               &_ConversationReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ConversationReply* other);
  friend void swap(ConversationReply& a, ConversationReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConversationReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ConversationReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConversationReply& from);
  void MergeFrom(const ConversationReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConversationReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes content = 4;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 4;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // required bytes signature = 5;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // required uint32 session_id = 2;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // required uint32 message_id = 3;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  ::google::protobuf::uint32 message_id() const;
  void set_message_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ConversationReply)
 private:
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_message_id();
  void clear_has_message_id();
  void set_has_content();
  void clear_has_content();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 message_id_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EndRequest) */ {
 public:
  EndRequest();
  virtual ~EndRequest();

  EndRequest(const EndRequest& from);

  inline EndRequest& operator=(const EndRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndRequest(EndRequest&& from) noexcept
    : EndRequest() {
    *this = ::std::move(from);
  }

  inline EndRequest& operator=(EndRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndRequest& default_instance();

  static inline const EndRequest* internal_default_instance() {
    return reinterpret_cast<const EndRequest*>(
               &_EndRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(EndRequest* other);
  friend void swap(EndRequest& a, EndRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EndRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EndRequest& from);
  void MergeFrom(const EndRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EndRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:EndRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EndReply) */ {
 public:
  EndReply();
  virtual ~EndReply();

  EndReply(const EndReply& from);

  inline EndReply& operator=(const EndReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndReply(EndReply&& from) noexcept
    : EndReply() {
    *this = ::std::move(from);
  }

  inline EndReply& operator=(EndReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndReply& default_instance();

  static inline const EndReply* internal_default_instance() {
    return reinterpret_cast<const EndReply*>(
               &_EndReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(EndReply* other);
  friend void swap(EndReply& a, EndReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndReply* New() const PROTOBUF_FINAL { return New(NULL); }

  EndReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EndReply& from);
  void MergeFrom(const EndReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EndReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:EndReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CheckRequest) */ {
 public:
  CheckRequest();
  virtual ~CheckRequest();

  CheckRequest(const CheckRequest& from);

  inline CheckRequest& operator=(const CheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckRequest(CheckRequest&& from) noexcept
    : CheckRequest() {
    *this = ::std::move(from);
  }

  inline CheckRequest& operator=(CheckRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckRequest& default_instance();

  static inline const CheckRequest* internal_default_instance() {
    return reinterpret_cast<const CheckRequest*>(
               &_CheckRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(CheckRequest* other);
  friend void swap(CheckRequest& a, CheckRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckRequest& from);
  void MergeFrom(const CheckRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CheckRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CheckReply) */ {
 public:
  CheckReply();
  virtual ~CheckReply();

  CheckReply(const CheckReply& from);

  inline CheckReply& operator=(const CheckReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckReply(CheckReply&& from) noexcept
    : CheckReply() {
    *this = ::std::move(from);
  }

  inline CheckReply& operator=(CheckReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckReply& default_instance();

  static inline const CheckReply* internal_default_instance() {
    return reinterpret_cast<const CheckReply*>(
               &_CheckReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(CheckReply* other);
  friend void swap(CheckReply& a, CheckReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckReply* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckReply& from);
  void MergeFrom(const CheckReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dev_id = 3;
  bool has_dev_id() const;
  void clear_dev_id();
  static const int kDevIdFieldNumber = 3;
  const ::std::string& dev_id() const;
  void set_dev_id(const ::std::string& value);
  #if LANG_CXX11
  void set_dev_id(::std::string&& value);
  #endif
  void set_dev_id(const char* value);
  void set_dev_id(const char* value, size_t size);
  ::std::string* mutable_dev_id();
  ::std::string* release_dev_id();
  void set_allocated_dev_id(::std::string* dev_id);

  // required int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CheckReply)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_dev_id();
  void clear_has_dev_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dev_id_;
  ::google::protobuf::int32 state_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InitRequest) */ {
 public:
  InitRequest();
  virtual ~InitRequest();

  InitRequest(const InitRequest& from);

  inline InitRequest& operator=(const InitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitRequest(InitRequest&& from) noexcept
    : InitRequest() {
    *this = ::std::move(from);
  }

  inline InitRequest& operator=(InitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitRequest& default_instance();

  static inline const InitRequest* internal_default_instance() {
    return reinterpret_cast<const InitRequest*>(
               &_InitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(InitRequest* other);
  friend void swap(InitRequest& a, InitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  InitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InitRequest& from);
  void MergeFrom(const InitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 2 [(.nanopb) = {
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:InitRequest)
 private:
  void set_has_password();
  void clear_has_password();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InitReply) */ {
 public:
  InitReply();
  virtual ~InitReply();

  InitReply(const InitReply& from);

  inline InitReply& operator=(const InitReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitReply(InitReply&& from) noexcept
    : InitReply() {
    *this = ::std::move(from);
  }

  inline InitReply& operator=(InitReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitReply& default_instance();

  static inline const InitReply* internal_default_instance() {
    return reinterpret_cast<const InitReply*>(
               &_InitReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(InitReply* other);
  friend void swap(InitReply& a, InitReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitReply* New() const PROTOBUF_FINAL { return New(NULL); }

  InitReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InitReply& from);
  void MergeFrom(const InitReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InitReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes dev_id = 2 [(.nanopb) = {
  bool has_dev_id() const;
  void clear_dev_id();
  static const int kDevIdFieldNumber = 2;
  const ::std::string& dev_id() const;
  void set_dev_id(const ::std::string& value);
  #if LANG_CXX11
  void set_dev_id(::std::string&& value);
  #endif
  void set_dev_id(const char* value);
  void set_dev_id(const void* value, size_t size);
  ::std::string* mutable_dev_id();
  ::std::string* release_dev_id();
  void set_allocated_dev_id(::std::string* dev_id);

  // @@protoc_insertion_point(class_scope:InitReply)
 private:
  void set_has_dev_id();
  void clear_has_dev_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dev_id_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PingRequest) */ {
 public:
  PingRequest();
  virtual ~PingRequest();

  PingRequest(const PingRequest& from);

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingRequest& default_instance();

  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(PingRequest* other);
  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PingRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingRequest& from);
  void MergeFrom(const PingRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PingRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PingReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PingReply) */ {
 public:
  PingReply();
  virtual ~PingReply();

  PingReply(const PingReply& from);

  inline PingReply& operator=(const PingReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingReply(PingReply&& from) noexcept
    : PingReply() {
    *this = ::std::move(from);
  }

  inline PingReply& operator=(PingReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingReply& default_instance();

  static inline const PingReply* internal_default_instance() {
    return reinterpret_cast<const PingReply*>(
               &_PingReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(PingReply* other);
  friend void swap(PingReply& a, PingReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingReply* New() const PROTOBUF_FINAL { return New(NULL); }

  PingReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingReply& from);
  void MergeFrom(const PingReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PingReply)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamp_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddCoinRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AddCoinRequest) */ {
 public:
  AddCoinRequest();
  virtual ~AddCoinRequest();

  AddCoinRequest(const AddCoinRequest& from);

  inline AddCoinRequest& operator=(const AddCoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddCoinRequest(AddCoinRequest&& from) noexcept
    : AddCoinRequest() {
    *this = ::std::move(from);
  }

  inline AddCoinRequest& operator=(AddCoinRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddCoinRequest& default_instance();

  static inline const AddCoinRequest* internal_default_instance() {
    return reinterpret_cast<const AddCoinRequest*>(
               &_AddCoinRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(AddCoinRequest* other);
  friend void swap(AddCoinRequest& a, AddCoinRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddCoinRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddCoinRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddCoinRequest& from);
  void MergeFrom(const AddCoinRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddCoinRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string symbol = 4;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // required string name = 5;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 idx = 3;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 3;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AddCoinRequest)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddCoinReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AddCoinReply) */ {
 public:
  AddCoinReply();
  virtual ~AddCoinReply();

  AddCoinReply(const AddCoinReply& from);

  inline AddCoinReply& operator=(const AddCoinReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddCoinReply(AddCoinReply&& from) noexcept
    : AddCoinReply() {
    *this = ::std::move(from);
  }

  inline AddCoinReply& operator=(AddCoinReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddCoinReply& default_instance();

  static inline const AddCoinReply* internal_default_instance() {
    return reinterpret_cast<const AddCoinReply*>(
               &_AddCoinReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(AddCoinReply* other);
  friend void swap(AddCoinReply& a, AddCoinReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddCoinReply* New() const PROTOBUF_FINAL { return New(NULL); }

  AddCoinReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddCoinReply& from);
  void MergeFrom(const AddCoinReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddCoinReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AddCoinReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateAddressRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateAddressRequest) */ {
 public:
  CreateAddressRequest();
  virtual ~CreateAddressRequest();

  CreateAddressRequest(const CreateAddressRequest& from);

  inline CreateAddressRequest& operator=(const CreateAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateAddressRequest(CreateAddressRequest&& from) noexcept
    : CreateAddressRequest() {
    *this = ::std::move(from);
  }

  inline CreateAddressRequest& operator=(CreateAddressRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateAddressRequest& default_instance();

  static inline const CreateAddressRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAddressRequest*>(
               &_CreateAddressRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(CreateAddressRequest* other);
  friend void swap(CreateAddressRequest& a, CreateAddressRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateAddressRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateAddressRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateAddressRequest& from);
  void MergeFrom(const CreateAddressRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateAddressRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1 [(.nanopb) = {
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 idx = 3;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 3;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateAddressRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateAddressReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateAddressReply) */ {
 public:
  CreateAddressReply();
  virtual ~CreateAddressReply();

  CreateAddressReply(const CreateAddressReply& from);

  inline CreateAddressReply& operator=(const CreateAddressReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateAddressReply(CreateAddressReply&& from) noexcept
    : CreateAddressReply() {
    *this = ::std::move(from);
  }

  inline CreateAddressReply& operator=(CreateAddressReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateAddressReply& default_instance();

  static inline const CreateAddressReply* internal_default_instance() {
    return reinterpret_cast<const CreateAddressReply*>(
               &_CreateAddressReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(CreateAddressReply* other);
  friend void swap(CreateAddressReply& a, CreateAddressReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateAddressReply* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateAddressReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateAddressReply& from);
  void MergeFrom(const CreateAddressReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateAddressReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 3 [(.nanopb) = {
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 3;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 idx = 2;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 2;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateAddressReply)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();
  void set_has_address();
  void clear_has_address();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateSecretRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateSecretRequest) */ {
 public:
  CreateSecretRequest();
  virtual ~CreateSecretRequest();

  CreateSecretRequest(const CreateSecretRequest& from);

  inline CreateSecretRequest& operator=(const CreateSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateSecretRequest(CreateSecretRequest&& from) noexcept
    : CreateSecretRequest() {
    *this = ::std::move(from);
  }

  inline CreateSecretRequest& operator=(CreateSecretRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSecretRequest& default_instance();

  static inline const CreateSecretRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSecretRequest*>(
               &_CreateSecretRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(CreateSecretRequest* other);
  friend void swap(CreateSecretRequest& a, CreateSecretRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateSecretRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateSecretRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateSecretRequest& from);
  void MergeFrom(const CreateSecretRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateSecretRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1 [(.nanopb) = {
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 site = 3;
  bool has_site() const;
  void clear_site();
  static const int kSiteFieldNumber = 3;
  ::google::protobuf::uint32 site() const;
  void set_site(::google::protobuf::uint32 value);

  // required uint32 account = 4;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 4;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateSecretRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_site();
  void clear_has_site();
  void set_has_account();
  void clear_has_account();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 site_;
  ::google::protobuf::uint32 account_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateSecretReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateSecretReply) */ {
 public:
  CreateSecretReply();
  virtual ~CreateSecretReply();

  CreateSecretReply(const CreateSecretReply& from);

  inline CreateSecretReply& operator=(const CreateSecretReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateSecretReply(CreateSecretReply&& from) noexcept
    : CreateSecretReply() {
    *this = ::std::move(from);
  }

  inline CreateSecretReply& operator=(CreateSecretReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSecretReply& default_instance();

  static inline const CreateSecretReply* internal_default_instance() {
    return reinterpret_cast<const CreateSecretReply*>(
               &_CreateSecretReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(CreateSecretReply* other);
  friend void swap(CreateSecretReply& a, CreateSecretReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateSecretReply* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateSecretReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateSecretReply& from);
  void MergeFrom(const CreateSecretReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateSecretReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes secret = 5 [(.nanopb) = {
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 5;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 site = 2;
  bool has_site() const;
  void clear_site();
  static const int kSiteFieldNumber = 2;
  ::google::protobuf::uint32 site() const;
  void set_site(::google::protobuf::uint32 value);

  // required uint32 account = 3;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 3;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // required uint32 index = 4;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateSecretReply)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_site();
  void clear_has_site();
  void set_has_account();
  void clear_has_account();
  void set_has_index();
  void clear_has_index();
  void set_has_secret();
  void clear_has_secret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 site_;
  ::google::protobuf::uint32 account_;
  ::google::protobuf::uint32 index_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddSecretRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AddSecretRequest) */ {
 public:
  AddSecretRequest();
  virtual ~AddSecretRequest();

  AddSecretRequest(const AddSecretRequest& from);

  inline AddSecretRequest& operator=(const AddSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddSecretRequest(AddSecretRequest&& from) noexcept
    : AddSecretRequest() {
    *this = ::std::move(from);
  }

  inline AddSecretRequest& operator=(AddSecretRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddSecretRequest& default_instance();

  static inline const AddSecretRequest* internal_default_instance() {
    return reinterpret_cast<const AddSecretRequest*>(
               &_AddSecretRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(AddSecretRequest* other);
  friend void swap(AddSecretRequest& a, AddSecretRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddSecretRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddSecretRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddSecretRequest& from);
  void MergeFrom(const AddSecretRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddSecretRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1 [(.nanopb) = {
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required bytes secret = 5 [(.nanopb) = {
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 5;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 site = 3;
  bool has_site() const;
  void clear_site();
  static const int kSiteFieldNumber = 3;
  ::google::protobuf::uint32 site() const;
  void set_site(::google::protobuf::uint32 value);

  // required uint32 account = 4;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 4;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AddSecretRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_site();
  void clear_has_site();
  void set_has_account();
  void clear_has_account();
  void set_has_secret();
  void clear_has_secret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 site_;
  ::google::protobuf::uint32 account_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddSecretReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AddSecretReply) */ {
 public:
  AddSecretReply();
  virtual ~AddSecretReply();

  AddSecretReply(const AddSecretReply& from);

  inline AddSecretReply& operator=(const AddSecretReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddSecretReply(AddSecretReply&& from) noexcept
    : AddSecretReply() {
    *this = ::std::move(from);
  }

  inline AddSecretReply& operator=(AddSecretReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddSecretReply& default_instance();

  static inline const AddSecretReply* internal_default_instance() {
    return reinterpret_cast<const AddSecretReply*>(
               &_AddSecretReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(AddSecretReply* other);
  friend void swap(AddSecretReply& a, AddSecretReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddSecretReply* New() const PROTOBUF_FINAL { return New(NULL); }

  AddSecretReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddSecretReply& from);
  void MergeFrom(const AddSecretReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddSecretReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes secret = 5 [(.nanopb) = {
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 5;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 site = 2;
  bool has_site() const;
  void clear_site();
  static const int kSiteFieldNumber = 2;
  ::google::protobuf::uint32 site() const;
  void set_site(::google::protobuf::uint32 value);

  // required uint32 account = 3;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 3;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // required uint32 idx = 4;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 4;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AddSecretReply)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_site();
  void clear_has_site();
  void set_has_account();
  void clear_has_account();
  void set_has_idx();
  void clear_has_idx();
  void set_has_secret();
  void clear_has_secret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 site_;
  ::google::protobuf::uint32 account_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignTxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SignTxRequest) */ {
 public:
  SignTxRequest();
  virtual ~SignTxRequest();

  SignTxRequest(const SignTxRequest& from);

  inline SignTxRequest& operator=(const SignTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignTxRequest(SignTxRequest&& from) noexcept
    : SignTxRequest() {
    *this = ::std::move(from);
  }

  inline SignTxRequest& operator=(SignTxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTxRequest& default_instance();

  static inline const SignTxRequest* internal_default_instance() {
    return reinterpret_cast<const SignTxRequest*>(
               &_SignTxRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(SignTxRequest* other);
  friend void swap(SignTxRequest& a, SignTxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignTxRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SignTxRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignTxRequest& from);
  void MergeFrom(const SignTxRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignTxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required string dest = 5 [(.nanopb) = {
  bool has_dest() const;
  void clear_dest();
  static const int kDestFieldNumber = 5;
  const ::std::string& dest() const;
  void set_dest(const ::std::string& value);
  #if LANG_CXX11
  void set_dest(::std::string&& value);
  #endif
  void set_dest(const char* value);
  void set_dest(const char* value, size_t size);
  ::std::string* mutable_dest();
  ::std::string* release_dest();
  void set_allocated_dest(::std::string* dest);

  // required bytes tx_hash = 6 [(.nanopb) = {
  bool has_tx_hash() const;
  void clear_tx_hash();
  static const int kTxHashFieldNumber = 6;
  const ::std::string& tx_hash() const;
  void set_tx_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_hash(::std::string&& value);
  #endif
  void set_tx_hash(const char* value);
  void set_tx_hash(const void* value, size_t size);
  ::std::string* mutable_tx_hash();
  ::std::string* release_tx_hash();
  void set_allocated_tx_hash(::std::string* tx_hash);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 idx = 3;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 3;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // required uint64 amount = 4;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // required uint32 tx_idx = 7;
  bool has_tx_idx() const;
  void clear_tx_idx();
  static const int kTxIdxFieldNumber = 7;
  ::google::protobuf::uint32 tx_idx() const;
  void set_tx_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SignTxRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();
  void set_has_amount();
  void clear_has_amount();
  void set_has_dest();
  void clear_has_dest();
  void set_has_tx_hash();
  void clear_has_tx_hash();
  void set_has_tx_idx();
  void clear_has_tx_idx();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr dest_;
  ::google::protobuf::internal::ArenaStringPtr tx_hash_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 tx_idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignTxReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SignTxReply) */ {
 public:
  SignTxReply();
  virtual ~SignTxReply();

  SignTxReply(const SignTxReply& from);

  inline SignTxReply& operator=(const SignTxReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignTxReply(SignTxReply&& from) noexcept
    : SignTxReply() {
    *this = ::std::move(from);
  }

  inline SignTxReply& operator=(SignTxReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTxReply& default_instance();

  static inline const SignTxReply* internal_default_instance() {
    return reinterpret_cast<const SignTxReply*>(
               &_SignTxReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(SignTxReply* other);
  friend void swap(SignTxReply& a, SignTxReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignTxReply* New() const PROTOBUF_FINAL { return New(NULL); }

  SignTxReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignTxReply& from);
  void MergeFrom(const SignTxReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignTxReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes signedTx = 2 [(.nanopb) = {
  bool has_signedtx() const;
  void clear_signedtx();
  static const int kSignedTxFieldNumber = 2;
  const ::std::string& signedtx() const;
  void set_signedtx(const ::std::string& value);
  #if LANG_CXX11
  void set_signedtx(::std::string&& value);
  #endif
  void set_signedtx(const char* value);
  void set_signedtx(const void* value, size_t size);
  ::std::string* mutable_signedtx();
  ::std::string* release_signedtx();
  void set_allocated_signedtx(::std::string* signedtx);

  // @@protoc_insertion_point(class_scope:SignTxReply)
 private:
  void set_has_signedtx();
  void clear_has_signedtx();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signedtx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignMsgRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SignMsgRequest) */ {
 public:
  SignMsgRequest();
  virtual ~SignMsgRequest();

  SignMsgRequest(const SignMsgRequest& from);

  inline SignMsgRequest& operator=(const SignMsgRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignMsgRequest(SignMsgRequest&& from) noexcept
    : SignMsgRequest() {
    *this = ::std::move(from);
  }

  inline SignMsgRequest& operator=(SignMsgRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignMsgRequest& default_instance();

  static inline const SignMsgRequest* internal_default_instance() {
    return reinterpret_cast<const SignMsgRequest*>(
               &_SignMsgRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(SignMsgRequest* other);
  friend void swap(SignMsgRequest& a, SignMsgRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignMsgRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SignMsgRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignMsgRequest& from);
  void MergeFrom(const SignMsgRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignMsgRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required bytes message = 4;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 idx = 3;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 3;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SignMsgRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();
  void set_has_message();
  void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignMsgReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SignMsgReply) */ {
 public:
  SignMsgReply();
  virtual ~SignMsgReply();

  SignMsgReply(const SignMsgReply& from);

  inline SignMsgReply& operator=(const SignMsgReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignMsgReply(SignMsgReply&& from) noexcept
    : SignMsgReply() {
    *this = ::std::move(from);
  }

  inline SignMsgReply& operator=(SignMsgReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignMsgReply& default_instance();

  static inline const SignMsgReply* internal_default_instance() {
    return reinterpret_cast<const SignMsgReply*>(
               &_SignMsgReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(SignMsgReply* other);
  friend void swap(SignMsgReply& a, SignMsgReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignMsgReply* New() const PROTOBUF_FINAL { return New(NULL); }

  SignMsgReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignMsgReply& from);
  void MergeFrom(const SignMsgReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignMsgReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes signed = 1 [(.nanopb) = {
  bool has_signed_() const;
  void clear_signed_();
  static const int kSignedFieldNumber = 1;
  const ::std::string& signed_() const;
  void set_signed_(const ::std::string& value);
  #if LANG_CXX11
  void set_signed_(::std::string&& value);
  #endif
  void set_signed_(const char* value);
  void set_signed_(const void* value, size_t size);
  ::std::string* mutable_signed_();
  ::std::string* release_signed_();
  void set_allocated_signed_(::std::string* signed_);

  // @@protoc_insertion_point(class_scope:SignMsgReply)
 private:
  void set_has_signed_();
  void clear_has_signed_();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signed__;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListCoinRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListCoinRequest) */ {
 public:
  ListCoinRequest();
  virtual ~ListCoinRequest();

  ListCoinRequest(const ListCoinRequest& from);

  inline ListCoinRequest& operator=(const ListCoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListCoinRequest(ListCoinRequest&& from) noexcept
    : ListCoinRequest() {
    *this = ::std::move(from);
  }

  inline ListCoinRequest& operator=(ListCoinRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListCoinRequest& default_instance();

  static inline const ListCoinRequest* internal_default_instance() {
    return reinterpret_cast<const ListCoinRequest*>(
               &_ListCoinRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(ListCoinRequest* other);
  friend void swap(ListCoinRequest& a, ListCoinRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListCoinRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ListCoinRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListCoinRequest& from);
  void MergeFrom(const ListCoinRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListCoinRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ListCoinRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListCoinReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListCoinReply) */ {
 public:
  ListCoinReply();
  virtual ~ListCoinReply();

  ListCoinReply(const ListCoinReply& from);

  inline ListCoinReply& operator=(const ListCoinReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListCoinReply(ListCoinReply&& from) noexcept
    : ListCoinReply() {
    *this = ::std::move(from);
  }

  inline ListCoinReply& operator=(ListCoinReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListCoinReply& default_instance();

  static inline const ListCoinReply* internal_default_instance() {
    return reinterpret_cast<const ListCoinReply*>(
               &_ListCoinReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(ListCoinReply* other);
  friend void swap(ListCoinReply& a, ListCoinReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListCoinReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ListCoinReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListCoinReply& from);
  void MergeFrom(const ListCoinReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListCoinReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 type = 3 [(.nanopb) = {
  int type_size() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint32 type(int index) const;
  void set_type(int index, ::google::protobuf::uint32 value);
  void add_type(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      type() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_type();

  // required uint32 max = 2;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 2;
  ::google::protobuf::uint32 max() const;
  void set_max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ListCoinReply)
 private:
  void set_has_max();
  void clear_has_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > type_;
  ::google::protobuf::uint32 max_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAddressRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GetAddressRequest) */ {
 public:
  GetAddressRequest();
  virtual ~GetAddressRequest();

  GetAddressRequest(const GetAddressRequest& from);

  inline GetAddressRequest& operator=(const GetAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAddressRequest(GetAddressRequest&& from) noexcept
    : GetAddressRequest() {
    *this = ::std::move(from);
  }

  inline GetAddressRequest& operator=(GetAddressRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAddressRequest& default_instance();

  static inline const GetAddressRequest* internal_default_instance() {
    return reinterpret_cast<const GetAddressRequest*>(
               &_GetAddressRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(GetAddressRequest* other);
  friend void swap(GetAddressRequest& a, GetAddressRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAddressRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAddressRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAddressRequest& from);
  void MergeFrom(const GetAddressRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAddressRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 idx = 3;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 3;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GetAddressRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAddressReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GetAddressReply) */ {
 public:
  GetAddressReply();
  virtual ~GetAddressReply();

  GetAddressReply(const GetAddressReply& from);

  inline GetAddressReply& operator=(const GetAddressReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAddressReply(GetAddressReply&& from) noexcept
    : GetAddressReply() {
    *this = ::std::move(from);
  }

  inline GetAddressReply& operator=(GetAddressReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAddressReply& default_instance();

  static inline const GetAddressReply* internal_default_instance() {
    return reinterpret_cast<const GetAddressReply*>(
               &_GetAddressReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(GetAddressReply* other);
  friend void swap(GetAddressReply& a, GetAddressReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAddressReply* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAddressReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAddressReply& from);
  void MergeFrom(const GetAddressReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAddressReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Address addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::Address& addr() const;
  ::Address* mutable_addr();
  ::Address* release_addr();
  void set_allocated_addr(::Address* addr);

  // @@protoc_insertion_point(class_scope:GetAddressReply)
 private:
  void set_has_addr();
  void clear_has_addr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Address* addr_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListAddressRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListAddressRequest) */ {
 public:
  ListAddressRequest();
  virtual ~ListAddressRequest();

  ListAddressRequest(const ListAddressRequest& from);

  inline ListAddressRequest& operator=(const ListAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListAddressRequest(ListAddressRequest&& from) noexcept
    : ListAddressRequest() {
    *this = ::std::move(from);
  }

  inline ListAddressRequest& operator=(ListAddressRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListAddressRequest& default_instance();

  static inline const ListAddressRequest* internal_default_instance() {
    return reinterpret_cast<const ListAddressRequest*>(
               &_ListAddressRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(ListAddressRequest* other);
  friend void swap(ListAddressRequest& a, ListAddressRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListAddressRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ListAddressRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListAddressRequest& from);
  void MergeFrom(const ListAddressRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListAddressRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 offset = 3;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required uint32 limit = 4;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 4;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ListAddressRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_offset();
  void clear_has_offset();
  void set_has_limit();
  void clear_has_limit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 limit_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Address) */ {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(Address&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(Address* other);
  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Address* New() const PROTOBUF_FINAL { return New(NULL); }

  Address* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Address* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string s_addr = 4 [(.nanopb) = {
  bool has_s_addr() const;
  void clear_s_addr();
  static const int kSAddrFieldNumber = 4;
  const ::std::string& s_addr() const;
  void set_s_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_s_addr(::std::string&& value);
  #endif
  void set_s_addr(const char* value);
  void set_s_addr(const char* value, size_t size);
  ::std::string* mutable_s_addr();
  ::std::string* release_s_addr();
  void set_allocated_s_addr(::std::string* s_addr);

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 idx = 2;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 2;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Address)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();
  void set_has_name();
  void clear_has_name();
  void set_has_s_addr();
  void clear_has_s_addr();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr s_addr_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListAddressReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListAddressReply) */ {
 public:
  ListAddressReply();
  virtual ~ListAddressReply();

  ListAddressReply(const ListAddressReply& from);

  inline ListAddressReply& operator=(const ListAddressReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListAddressReply(ListAddressReply&& from) noexcept
    : ListAddressReply() {
    *this = ::std::move(from);
  }

  inline ListAddressReply& operator=(ListAddressReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListAddressReply& default_instance();

  static inline const ListAddressReply* internal_default_instance() {
    return reinterpret_cast<const ListAddressReply*>(
               &_ListAddressReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(ListAddressReply* other);
  friend void swap(ListAddressReply& a, ListAddressReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListAddressReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ListAddressReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListAddressReply& from);
  void MergeFrom(const ListAddressReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListAddressReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Address addr = 5 [(.nanopb) = {
  int addr_size() const;
  void clear_addr();
  static const int kAddrFieldNumber = 5;
  const ::Address& addr(int index) const;
  ::Address* mutable_addr(int index);
  ::Address* add_addr();
  ::google::protobuf::RepeatedPtrField< ::Address >*
      mutable_addr();
  const ::google::protobuf::RepeatedPtrField< ::Address >&
      addr() const;

  // required uint32 total_records = 1;
  bool has_total_records() const;
  void clear_total_records();
  static const int kTotalRecordsFieldNumber = 1;
  ::google::protobuf::uint32 total_records() const;
  void set_total_records(::google::protobuf::uint32 value);

  // required uint32 total_pages = 2;
  bool has_total_pages() const;
  void clear_total_pages();
  static const int kTotalPagesFieldNumber = 2;
  ::google::protobuf::uint32 total_pages() const;
  void set_total_pages(::google::protobuf::uint32 value);

  // required uint32 limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // required uint32 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ListAddressReply)
 private:
  void set_has_total_records();
  void clear_has_total_records();
  void set_has_total_pages();
  void clear_has_total_pages();
  void set_has_limit();
  void clear_has_limit();
  void set_has_offset();
  void clear_has_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Address > addr_;
  ::google::protobuf::uint32 total_records_;
  ::google::protobuf::uint32 total_pages_;
  ::google::protobuf::uint32 limit_;
  ::google::protobuf::uint32 offset_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListSecretRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListSecretRequest) */ {
 public:
  ListSecretRequest();
  virtual ~ListSecretRequest();

  ListSecretRequest(const ListSecretRequest& from);

  inline ListSecretRequest& operator=(const ListSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListSecretRequest(ListSecretRequest&& from) noexcept
    : ListSecretRequest() {
    *this = ::std::move(from);
  }

  inline ListSecretRequest& operator=(ListSecretRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSecretRequest& default_instance();

  static inline const ListSecretRequest* internal_default_instance() {
    return reinterpret_cast<const ListSecretRequest*>(
               &_ListSecretRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(ListSecretRequest* other);
  friend void swap(ListSecretRequest& a, ListSecretRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListSecretRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ListSecretRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListSecretRequest& from);
  void MergeFrom(const ListSecretRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListSecretRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 site = 3;
  bool has_site() const;
  void clear_site();
  static const int kSiteFieldNumber = 3;
  ::google::protobuf::uint32 site() const;
  void set_site(::google::protobuf::uint32 value);

  // optional uint32 account = 4;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 4;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // required uint32 offset = 5;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 5;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required uint32 limit = 6;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ListSecretRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_site();
  void clear_has_site();
  void set_has_account();
  void clear_has_account();
  void set_has_offset();
  void clear_has_offset();
  void set_has_limit();
  void clear_has_limit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 site_;
  ::google::protobuf::uint32 account_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 limit_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Secret) */ {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Secret(Secret&& from) noexcept
    : Secret() {
    *this = ::std::move(from);
  }

  inline Secret& operator=(Secret&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret& default_instance();

  static inline const Secret* internal_default_instance() {
    return reinterpret_cast<const Secret*>(
               &_Secret_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(Secret* other);
  friend void swap(Secret& a, Secret& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Secret* New() const PROTOBUF_FINAL { return New(NULL); }

  Secret* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Secret* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes s_secret = 5 [(.nanopb) = {
  bool has_s_secret() const;
  void clear_s_secret();
  static const int kSSecretFieldNumber = 5;
  const ::std::string& s_secret() const;
  void set_s_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_s_secret(::std::string&& value);
  #endif
  void set_s_secret(const char* value);
  void set_s_secret(const void* value, size_t size);
  ::std::string* mutable_s_secret();
  ::std::string* release_s_secret();
  void set_allocated_s_secret(::std::string* s_secret);

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 site = 2;
  bool has_site() const;
  void clear_site();
  static const int kSiteFieldNumber = 2;
  ::google::protobuf::uint32 site() const;
  void set_site(::google::protobuf::uint32 value);

  // required uint32 account = 3;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 3;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // required uint32 idx = 4;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 4;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Secret)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_site();
  void clear_has_site();
  void set_has_account();
  void clear_has_account();
  void set_has_idx();
  void clear_has_idx();
  void set_has_s_secret();
  void clear_has_s_secret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr s_secret_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 site_;
  ::google::protobuf::uint32 account_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListSecretReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListSecretReply) */ {
 public:
  ListSecretReply();
  virtual ~ListSecretReply();

  ListSecretReply(const ListSecretReply& from);

  inline ListSecretReply& operator=(const ListSecretReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListSecretReply(ListSecretReply&& from) noexcept
    : ListSecretReply() {
    *this = ::std::move(from);
  }

  inline ListSecretReply& operator=(ListSecretReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSecretReply& default_instance();

  static inline const ListSecretReply* internal_default_instance() {
    return reinterpret_cast<const ListSecretReply*>(
               &_ListSecretReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(ListSecretReply* other);
  friend void swap(ListSecretReply& a, ListSecretReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListSecretReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ListSecretReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListSecretReply& from);
  void MergeFrom(const ListSecretReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListSecretReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Secret secret = 5 [(.nanopb) = {
  int secret_size() const;
  void clear_secret();
  static const int kSecretFieldNumber = 5;
  const ::Secret& secret(int index) const;
  ::Secret* mutable_secret(int index);
  ::Secret* add_secret();
  ::google::protobuf::RepeatedPtrField< ::Secret >*
      mutable_secret();
  const ::google::protobuf::RepeatedPtrField< ::Secret >&
      secret() const;

  // required uint32 total_records = 1;
  bool has_total_records() const;
  void clear_total_records();
  static const int kTotalRecordsFieldNumber = 1;
  ::google::protobuf::uint32 total_records() const;
  void set_total_records(::google::protobuf::uint32 value);

  // required uint32 total_pages = 2;
  bool has_total_pages() const;
  void clear_total_pages();
  static const int kTotalPagesFieldNumber = 2;
  ::google::protobuf::uint32 total_pages() const;
  void set_total_pages(::google::protobuf::uint32 value);

  // required uint32 limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // required uint32 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ListSecretReply)
 private:
  void set_has_total_records();
  void clear_has_total_records();
  void set_has_total_pages();
  void clear_has_total_pages();
  void set_has_limit();
  void clear_has_limit();
  void set_has_offset();
  void clear_has_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Secret > secret_;
  ::google::protobuf::uint32 total_records_;
  ::google::protobuf::uint32 total_pages_;
  ::google::protobuf::uint32 limit_;
  ::google::protobuf::uint32 offset_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemoveCoinRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RemoveCoinRequest) */ {
 public:
  RemoveCoinRequest();
  virtual ~RemoveCoinRequest();

  RemoveCoinRequest(const RemoveCoinRequest& from);

  inline RemoveCoinRequest& operator=(const RemoveCoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveCoinRequest(RemoveCoinRequest&& from) noexcept
    : RemoveCoinRequest() {
    *this = ::std::move(from);
  }

  inline RemoveCoinRequest& operator=(RemoveCoinRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveCoinRequest& default_instance();

  static inline const RemoveCoinRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveCoinRequest*>(
               &_RemoveCoinRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(RemoveCoinRequest* other);
  friend void swap(RemoveCoinRequest& a, RemoveCoinRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveCoinRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoveCoinRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoveCoinRequest& from);
  void MergeFrom(const RemoveCoinRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoveCoinRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RemoveCoinRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 type_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemoveCoinReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RemoveCoinReply) */ {
 public:
  RemoveCoinReply();
  virtual ~RemoveCoinReply();

  RemoveCoinReply(const RemoveCoinReply& from);

  inline RemoveCoinReply& operator=(const RemoveCoinReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveCoinReply(RemoveCoinReply&& from) noexcept
    : RemoveCoinReply() {
    *this = ::std::move(from);
  }

  inline RemoveCoinReply& operator=(RemoveCoinReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveCoinReply& default_instance();

  static inline const RemoveCoinReply* internal_default_instance() {
    return reinterpret_cast<const RemoveCoinReply*>(
               &_RemoveCoinReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(RemoveCoinReply* other);
  friend void swap(RemoveCoinReply& a, RemoveCoinReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveCoinReply* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoveCoinReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoveCoinReply& from);
  void MergeFrom(const RemoveCoinReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoveCoinReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoveCoinReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteSecretRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DeleteSecretRequest) */ {
 public:
  DeleteSecretRequest();
  virtual ~DeleteSecretRequest();

  DeleteSecretRequest(const DeleteSecretRequest& from);

  inline DeleteSecretRequest& operator=(const DeleteSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteSecretRequest(DeleteSecretRequest&& from) noexcept
    : DeleteSecretRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSecretRequest& operator=(DeleteSecretRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteSecretRequest& default_instance();

  static inline const DeleteSecretRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSecretRequest*>(
               &_DeleteSecretRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(DeleteSecretRequest* other);
  friend void swap(DeleteSecretRequest& a, DeleteSecretRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteSecretRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteSecretRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteSecretRequest& from);
  void MergeFrom(const DeleteSecretRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteSecretRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 idx = 3;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 3;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DeleteSecretRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteSecretReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DeleteSecretReply) */ {
 public:
  DeleteSecretReply();
  virtual ~DeleteSecretReply();

  DeleteSecretReply(const DeleteSecretReply& from);

  inline DeleteSecretReply& operator=(const DeleteSecretReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteSecretReply(DeleteSecretReply&& from) noexcept
    : DeleteSecretReply() {
    *this = ::std::move(from);
  }

  inline DeleteSecretReply& operator=(DeleteSecretReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteSecretReply& default_instance();

  static inline const DeleteSecretReply* internal_default_instance() {
    return reinterpret_cast<const DeleteSecretReply*>(
               &_DeleteSecretReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(DeleteSecretReply* other);
  friend void swap(DeleteSecretReply& a, DeleteSecretReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteSecretReply* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteSecretReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteSecretReply& from);
  void MergeFrom(const DeleteSecretReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteSecretReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DeleteSecretReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteAddressRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DeleteAddressRequest) */ {
 public:
  DeleteAddressRequest();
  virtual ~DeleteAddressRequest();

  DeleteAddressRequest(const DeleteAddressRequest& from);

  inline DeleteAddressRequest& operator=(const DeleteAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteAddressRequest(DeleteAddressRequest&& from) noexcept
    : DeleteAddressRequest() {
    *this = ::std::move(from);
  }

  inline DeleteAddressRequest& operator=(DeleteAddressRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteAddressRequest& default_instance();

  static inline const DeleteAddressRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAddressRequest*>(
               &_DeleteAddressRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(DeleteAddressRequest* other);
  friend void swap(DeleteAddressRequest& a, DeleteAddressRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteAddressRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteAddressRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteAddressRequest& from);
  void MergeFrom(const DeleteAddressRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteAddressRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 idx = 3;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 3;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DeleteAddressRequest)
 private:
  void set_has_password();
  void clear_has_password();
  void set_has_type();
  void clear_has_type();
  void set_has_idx();
  void clear_has_idx();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 idx_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteAddressReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DeleteAddressReply) */ {
 public:
  DeleteAddressReply();
  virtual ~DeleteAddressReply();

  DeleteAddressReply(const DeleteAddressReply& from);

  inline DeleteAddressReply& operator=(const DeleteAddressReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteAddressReply(DeleteAddressReply&& from) noexcept
    : DeleteAddressReply() {
    *this = ::std::move(from);
  }

  inline DeleteAddressReply& operator=(DeleteAddressReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteAddressReply& default_instance();

  static inline const DeleteAddressReply* internal_default_instance() {
    return reinterpret_cast<const DeleteAddressReply*>(
               &_DeleteAddressReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(DeleteAddressReply* other);
  friend void swap(DeleteAddressReply& a, DeleteAddressReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteAddressReply* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteAddressReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteAddressReply& from);
  void MergeFrom(const DeleteAddressReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteAddressReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DeleteAddressReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ResetRequest) */ {
 public:
  ResetRequest();
  virtual ~ResetRequest();

  ResetRequest(const ResetRequest& from);

  inline ResetRequest& operator=(const ResetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetRequest(ResetRequest&& from) noexcept
    : ResetRequest() {
    *this = ::std::move(from);
  }

  inline ResetRequest& operator=(ResetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetRequest& default_instance();

  static inline const ResetRequest* internal_default_instance() {
    return reinterpret_cast<const ResetRequest*>(
               &_ResetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(ResetRequest* other);
  friend void swap(ResetRequest& a, ResetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetRequest& from);
  void MergeFrom(const ResetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 1;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:ResetRequest)
 private:
  void set_has_password();
  void clear_has_password();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ResetReply) */ {
 public:
  ResetReply();
  virtual ~ResetReply();

  ResetReply(const ResetReply& from);

  inline ResetReply& operator=(const ResetReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetReply(ResetReply&& from) noexcept
    : ResetReply() {
    *this = ::std::move(from);
  }

  inline ResetReply& operator=(ResetReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetReply& default_instance();

  static inline const ResetReply* internal_default_instance() {
    return reinterpret_cast<const ResetReply*>(
               &_ResetReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(ResetReply* other);
  friend void swap(ResetReply& a, ResetReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetReply& from);
  void MergeFrom(const ResetReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ResetReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DispMsgRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DispMsgRequest) */ {
 public:
  DispMsgRequest();
  virtual ~DispMsgRequest();

  DispMsgRequest(const DispMsgRequest& from);

  inline DispMsgRequest& operator=(const DispMsgRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DispMsgRequest(DispMsgRequest&& from) noexcept
    : DispMsgRequest() {
    *this = ::std::move(from);
  }

  inline DispMsgRequest& operator=(DispMsgRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DispMsgRequest& default_instance();

  static inline const DispMsgRequest* internal_default_instance() {
    return reinterpret_cast<const DispMsgRequest*>(
               &_DispMsgRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(DispMsgRequest* other);
  friend void swap(DispMsgRequest& a, DispMsgRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DispMsgRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DispMsgRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DispMsgRequest& from);
  void MergeFrom(const DispMsgRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DispMsgRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes title = 1;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 1;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const void* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // required bytes content = 2;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // required bytes icon = 3;
  bool has_icon() const;
  void clear_icon();
  static const int kIconFieldNumber = 3;
  const ::std::string& icon() const;
  void set_icon(const ::std::string& value);
  #if LANG_CXX11
  void set_icon(::std::string&& value);
  #endif
  void set_icon(const char* value);
  void set_icon(const void* value, size_t size);
  ::std::string* mutable_icon();
  ::std::string* release_icon();
  void set_allocated_icon(::std::string* icon);

  // @@protoc_insertion_point(class_scope:DispMsgRequest)
 private:
  void set_has_title();
  void clear_has_title();
  void set_has_content();
  void clear_has_content();
  void set_has_icon();
  void clear_has_icon();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr icon_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DispMsgReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DispMsgReply) */ {
 public:
  DispMsgReply();
  virtual ~DispMsgReply();

  DispMsgReply(const DispMsgReply& from);

  inline DispMsgReply& operator=(const DispMsgReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DispMsgReply(DispMsgReply&& from) noexcept
    : DispMsgReply() {
    *this = ::std::move(from);
  }

  inline DispMsgReply& operator=(DispMsgReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DispMsgReply& default_instance();

  static inline const DispMsgReply* internal_default_instance() {
    return reinterpret_cast<const DispMsgReply*>(
               &_DispMsgReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(DispMsgReply* other);
  friend void swap(DispMsgReply& a, DispMsgReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DispMsgReply* New() const PROTOBUF_FINAL { return New(NULL); }

  DispMsgReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DispMsgReply& from);
  void MergeFrom(const DispMsgReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DispMsgReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:DispMsgReply)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool result_;
  friend struct protobuf_icebox_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Timestamp

// required int64 seconds = 1;
inline bool Timestamp::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timestamp::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timestamp::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timestamp::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
  clear_has_seconds();
}
inline ::google::protobuf::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:Timestamp.seconds)
  return seconds_;
}
inline void Timestamp::set_seconds(::google::protobuf::int64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:Timestamp.seconds)
}

// required int32 nanos = 2;
inline bool Timestamp::has_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timestamp::set_has_nanos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timestamp::clear_has_nanos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timestamp::clear_nanos() {
  nanos_ = 0;
  clear_has_nanos();
}
inline ::google::protobuf::int32 Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:Timestamp.nanos)
  return nanos_;
}
inline void Timestamp::set_nanos(::google::protobuf::int32 value) {
  set_has_nanos();
  nanos_ = value;
  // @@protoc_insertion_point(field_set:Timestamp.nanos)
}

// -------------------------------------------------------------------

// IceboxMessage_Header

// required uint32 version = 1 [default = 1];
inline bool IceboxMessage_Header::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IceboxMessage_Header::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IceboxMessage_Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IceboxMessage_Header::clear_version() {
  version_ = 1u;
  clear_has_version();
}
inline ::google::protobuf::uint32 IceboxMessage_Header::version() const {
  // @@protoc_insertion_point(field_get:IceboxMessage.Header.version)
  return version_;
}
inline void IceboxMessage_Header::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:IceboxMessage.Header.version)
}

// required .IceboxMessage.Type type = 2;
inline bool IceboxMessage_Header::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IceboxMessage_Header::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IceboxMessage_Header::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IceboxMessage_Header::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::IceboxMessage_Type IceboxMessage_Header::type() const {
  // @@protoc_insertion_point(field_get:IceboxMessage.Header.type)
  return static_cast< ::IceboxMessage_Type >(type_);
}
inline void IceboxMessage_Header::set_type(::IceboxMessage_Type value) {
  assert(::IceboxMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:IceboxMessage.Header.type)
}

// required .Timestamp timestamp = 3;
inline bool IceboxMessage_Header::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IceboxMessage_Header::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IceboxMessage_Header::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IceboxMessage_Header::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::Timestamp& IceboxMessage_Header::timestamp() const {
  const ::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:IceboxMessage.Header.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Timestamp*>(
      &::_Timestamp_default_instance_);
}
inline ::Timestamp* IceboxMessage_Header::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:IceboxMessage.Header.timestamp)
  return timestamp_;
}
inline ::Timestamp* IceboxMessage_Header::release_timestamp() {
  // @@protoc_insertion_point(field_release:IceboxMessage.Header.timestamp)
  clear_has_timestamp();
  ::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void IceboxMessage_Header::set_allocated_timestamp(::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:IceboxMessage.Header.timestamp)
}

// required uint32 session_id = 4;
inline bool IceboxMessage_Header::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IceboxMessage_Header::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IceboxMessage_Header::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IceboxMessage_Header::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IceboxMessage_Header::session_id() const {
  // @@protoc_insertion_point(field_get:IceboxMessage.Header.session_id)
  return session_id_;
}
inline void IceboxMessage_Header::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IceboxMessage.Header.session_id)
}

// -------------------------------------------------------------------

// IceboxMessage

// required .IceboxMessage.Header header = 1;
inline bool IceboxMessage::has_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IceboxMessage::set_has_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IceboxMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IceboxMessage::clear_header() {
  if (header_ != NULL) header_->::IceboxMessage_Header::Clear();
  clear_has_header();
}
inline const ::IceboxMessage_Header& IceboxMessage::header() const {
  const ::IceboxMessage_Header* p = header_;
  // @@protoc_insertion_point(field_get:IceboxMessage.header)
  return p != NULL ? *p : *reinterpret_cast<const ::IceboxMessage_Header*>(
      &::_IceboxMessage_Header_default_instance_);
}
inline ::IceboxMessage_Header* IceboxMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::IceboxMessage_Header;
  }
  // @@protoc_insertion_point(field_mutable:IceboxMessage.header)
  return header_;
}
inline ::IceboxMessage_Header* IceboxMessage::release_header() {
  // @@protoc_insertion_point(field_release:IceboxMessage.header)
  clear_has_header();
  ::IceboxMessage_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void IceboxMessage::set_allocated_header(::IceboxMessage_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:IceboxMessage.header)
}

// required bytes payload = 2;
inline bool IceboxMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IceboxMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IceboxMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IceboxMessage::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& IceboxMessage::payload() const {
  // @@protoc_insertion_point(field_get:IceboxMessage.payload)
  return payload_.GetNoArena();
}
inline void IceboxMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IceboxMessage.payload)
}
#if LANG_CXX11
inline void IceboxMessage::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IceboxMessage.payload)
}
#endif
inline void IceboxMessage::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IceboxMessage.payload)
}
inline void IceboxMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IceboxMessage.payload)
}
inline ::std::string* IceboxMessage::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:IceboxMessage.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IceboxMessage::release_payload() {
  // @@protoc_insertion_point(field_release:IceboxMessage.payload)
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IceboxMessage::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:IceboxMessage.payload)
}

// required bytes signature = 3;
inline bool IceboxMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IceboxMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IceboxMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IceboxMessage::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& IceboxMessage::signature() const {
  // @@protoc_insertion_point(field_get:IceboxMessage.signature)
  return signature_.GetNoArena();
}
inline void IceboxMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IceboxMessage.signature)
}
#if LANG_CXX11
inline void IceboxMessage::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IceboxMessage.signature)
}
#endif
inline void IceboxMessage::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IceboxMessage.signature)
}
inline void IceboxMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IceboxMessage.signature)
}
inline ::std::string* IceboxMessage::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:IceboxMessage.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IceboxMessage::release_signature() {
  // @@protoc_insertion_point(field_release:IceboxMessage.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IceboxMessage::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:IceboxMessage.signature)
}

// -------------------------------------------------------------------

// Error

// required int32 code = 1;
inline bool Error::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 Error::code() const {
  // @@protoc_insertion_point(field_get:Error.code)
  return code_;
}
inline void Error::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:Error.code)
}

// optional string message = 2 [(.nanopb) = {
inline bool Error::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Error.message)
}
inline ::std::string* Error::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:Error.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Error.message)
}

// -------------------------------------------------------------------

// Header

// required uint32 ver = 1 [default = 1];
inline bool Header::has_ver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_ver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_ver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_ver() {
  ver_ = 1u;
  clear_has_ver();
}
inline ::google::protobuf::uint32 Header::ver() const {
  // @@protoc_insertion_point(field_get:Header.ver)
  return ver_;
}
inline void Header::set_ver(::google::protobuf::uint32 value) {
  set_has_ver();
  ver_ = value;
  // @@protoc_insertion_point(field_set:Header.ver)
}

// required uint32 sn = 2;
inline bool Header::has_sn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_sn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_sn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_sn() {
  sn_ = 0u;
  clear_has_sn();
}
inline ::google::protobuf::uint32 Header::sn() const {
  // @@protoc_insertion_point(field_get:Header.sn)
  return sn_;
}
inline void Header::set_sn(::google::protobuf::uint32 value) {
  set_has_sn();
  sn_ = value;
  // @@protoc_insertion_point(field_set:Header.sn)
}

// -------------------------------------------------------------------

// ReplyHeader

// required uint32 ver = 1 [default = 1];
inline bool ReplyHeader::has_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReplyHeader::set_has_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReplyHeader::clear_has_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReplyHeader::clear_ver() {
  ver_ = 1u;
  clear_has_ver();
}
inline ::google::protobuf::uint32 ReplyHeader::ver() const {
  // @@protoc_insertion_point(field_get:ReplyHeader.ver)
  return ver_;
}
inline void ReplyHeader::set_ver(::google::protobuf::uint32 value) {
  set_has_ver();
  ver_ = value;
  // @@protoc_insertion_point(field_set:ReplyHeader.ver)
}

// required uint32 sn = 2;
inline bool ReplyHeader::has_sn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplyHeader::set_has_sn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplyHeader::clear_has_sn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplyHeader::clear_sn() {
  sn_ = 0u;
  clear_has_sn();
}
inline ::google::protobuf::uint32 ReplyHeader::sn() const {
  // @@protoc_insertion_point(field_get:ReplyHeader.sn)
  return sn_;
}
inline void ReplyHeader::set_sn(::google::protobuf::uint32 value) {
  set_has_sn();
  sn_ = value;
  // @@protoc_insertion_point(field_set:ReplyHeader.sn)
}

// required uint32 code = 3;
inline bool ReplyHeader::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplyHeader::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplyHeader::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplyHeader::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 ReplyHeader::code() const {
  // @@protoc_insertion_point(field_get:ReplyHeader.code)
  return code_;
}
inline void ReplyHeader::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:ReplyHeader.code)
}

// optional string message = 4 [(.nanopb) = {
inline bool ReplyHeader::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplyHeader::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplyHeader::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplyHeader::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ReplyHeader::message() const {
  // @@protoc_insertion_point(field_get:ReplyHeader.message)
  return message_.GetNoArena();
}
inline void ReplyHeader::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ReplyHeader.message)
}
#if LANG_CXX11
inline void ReplyHeader::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ReplyHeader.message)
}
#endif
inline void ReplyHeader::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ReplyHeader.message)
}
inline void ReplyHeader::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ReplyHeader.message)
}
inline ::std::string* ReplyHeader::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:ReplyHeader.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReplyHeader::release_message() {
  // @@protoc_insertion_point(field_release:ReplyHeader.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReplyHeader::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ReplyHeader.message)
}

// -------------------------------------------------------------------

// HiRequest

// required int64 magicA = 2;
inline bool HiRequest::has_magica() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HiRequest::set_has_magica() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HiRequest::clear_has_magica() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HiRequest::clear_magica() {
  magica_ = GOOGLE_LONGLONG(0);
  clear_has_magica();
}
inline ::google::protobuf::int64 HiRequest::magica() const {
  // @@protoc_insertion_point(field_get:HiRequest.magicA)
  return magica_;
}
inline void HiRequest::set_magica(::google::protobuf::int64 value) {
  set_has_magica();
  magica_ = value;
  // @@protoc_insertion_point(field_set:HiRequest.magicA)
}

// -------------------------------------------------------------------

// HiReply

// required int64 magicB = 2;
inline bool HiReply::has_magicb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HiReply::set_has_magicb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HiReply::clear_has_magicb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HiReply::clear_magicb() {
  magicb_ = GOOGLE_LONGLONG(0);
  clear_has_magicb();
}
inline ::google::protobuf::int64 HiReply::magicb() const {
  // @@protoc_insertion_point(field_get:HiReply.magicB)
  return magicb_;
}
inline void HiReply::set_magicb(::google::protobuf::int64 value) {
  set_has_magicb();
  magicb_ = value;
  // @@protoc_insertion_point(field_set:HiReply.magicB)
}

// -------------------------------------------------------------------

// NegotiateRequest

// required string keyA = 2;
inline bool NegotiateRequest::has_keya() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NegotiateRequest::set_has_keya() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NegotiateRequest::clear_has_keya() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NegotiateRequest::clear_keya() {
  keya_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keya();
}
inline const ::std::string& NegotiateRequest::keya() const {
  // @@protoc_insertion_point(field_get:NegotiateRequest.keyA)
  return keya_.GetNoArena();
}
inline void NegotiateRequest::set_keya(const ::std::string& value) {
  set_has_keya();
  keya_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NegotiateRequest.keyA)
}
#if LANG_CXX11
inline void NegotiateRequest::set_keya(::std::string&& value) {
  set_has_keya();
  keya_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NegotiateRequest.keyA)
}
#endif
inline void NegotiateRequest::set_keya(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keya();
  keya_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NegotiateRequest.keyA)
}
inline void NegotiateRequest::set_keya(const char* value, size_t size) {
  set_has_keya();
  keya_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NegotiateRequest.keyA)
}
inline ::std::string* NegotiateRequest::mutable_keya() {
  set_has_keya();
  // @@protoc_insertion_point(field_mutable:NegotiateRequest.keyA)
  return keya_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NegotiateRequest::release_keya() {
  // @@protoc_insertion_point(field_release:NegotiateRequest.keyA)
  clear_has_keya();
  return keya_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NegotiateRequest::set_allocated_keya(::std::string* keya) {
  if (keya != NULL) {
    set_has_keya();
  } else {
    clear_has_keya();
  }
  keya_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keya);
  // @@protoc_insertion_point(field_set_allocated:NegotiateRequest.keyA)
}

// required string hash = 3;
inline bool NegotiateRequest::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NegotiateRequest::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NegotiateRequest::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NegotiateRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& NegotiateRequest::hash() const {
  // @@protoc_insertion_point(field_get:NegotiateRequest.hash)
  return hash_.GetNoArena();
}
inline void NegotiateRequest::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NegotiateRequest.hash)
}
#if LANG_CXX11
inline void NegotiateRequest::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NegotiateRequest.hash)
}
#endif
inline void NegotiateRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NegotiateRequest.hash)
}
inline void NegotiateRequest::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NegotiateRequest.hash)
}
inline ::std::string* NegotiateRequest::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:NegotiateRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NegotiateRequest::release_hash() {
  // @@protoc_insertion_point(field_release:NegotiateRequest.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NegotiateRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:NegotiateRequest.hash)
}

// -------------------------------------------------------------------

// NegotiateReply

// required string keyB = 2;
inline bool NegotiateReply::has_keyb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NegotiateReply::set_has_keyb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NegotiateReply::clear_has_keyb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NegotiateReply::clear_keyb() {
  keyb_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyb();
}
inline const ::std::string& NegotiateReply::keyb() const {
  // @@protoc_insertion_point(field_get:NegotiateReply.keyB)
  return keyb_.GetNoArena();
}
inline void NegotiateReply::set_keyb(const ::std::string& value) {
  set_has_keyb();
  keyb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NegotiateReply.keyB)
}
#if LANG_CXX11
inline void NegotiateReply::set_keyb(::std::string&& value) {
  set_has_keyb();
  keyb_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NegotiateReply.keyB)
}
#endif
inline void NegotiateReply::set_keyb(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyb();
  keyb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NegotiateReply.keyB)
}
inline void NegotiateReply::set_keyb(const char* value, size_t size) {
  set_has_keyb();
  keyb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NegotiateReply.keyB)
}
inline ::std::string* NegotiateReply::mutable_keyb() {
  set_has_keyb();
  // @@protoc_insertion_point(field_mutable:NegotiateReply.keyB)
  return keyb_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NegotiateReply::release_keyb() {
  // @@protoc_insertion_point(field_release:NegotiateReply.keyB)
  clear_has_keyb();
  return keyb_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NegotiateReply::set_allocated_keyb(::std::string* keyb) {
  if (keyb != NULL) {
    set_has_keyb();
  } else {
    clear_has_keyb();
  }
  keyb_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyb);
  // @@protoc_insertion_point(field_set_allocated:NegotiateReply.keyB)
}

// required string hash = 3;
inline bool NegotiateReply::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NegotiateReply::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NegotiateReply::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NegotiateReply::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& NegotiateReply::hash() const {
  // @@protoc_insertion_point(field_get:NegotiateReply.hash)
  return hash_.GetNoArena();
}
inline void NegotiateReply::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NegotiateReply.hash)
}
#if LANG_CXX11
inline void NegotiateReply::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NegotiateReply.hash)
}
#endif
inline void NegotiateReply::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NegotiateReply.hash)
}
inline void NegotiateReply::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NegotiateReply.hash)
}
inline ::std::string* NegotiateReply::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:NegotiateReply.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NegotiateReply::release_hash() {
  // @@protoc_insertion_point(field_release:NegotiateReply.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NegotiateReply::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:NegotiateReply.hash)
}

// -------------------------------------------------------------------

// StartRequest

// -------------------------------------------------------------------

// StartReply

// -------------------------------------------------------------------

// ConversationRequest

// required uint32 session_id = 2;
inline bool ConversationRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConversationRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConversationRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConversationRequest::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 ConversationRequest::session_id() const {
  // @@protoc_insertion_point(field_get:ConversationRequest.session_id)
  return session_id_;
}
inline void ConversationRequest::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:ConversationRequest.session_id)
}

// required uint32 message_id = 3;
inline bool ConversationRequest::has_message_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConversationRequest::set_has_message_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConversationRequest::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConversationRequest::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 ConversationRequest::message_id() const {
  // @@protoc_insertion_point(field_get:ConversationRequest.message_id)
  return message_id_;
}
inline void ConversationRequest::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:ConversationRequest.message_id)
}

// required bytes content = 4;
inline bool ConversationRequest::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConversationRequest::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConversationRequest::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConversationRequest::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& ConversationRequest::content() const {
  // @@protoc_insertion_point(field_get:ConversationRequest.content)
  return content_.GetNoArena();
}
inline void ConversationRequest::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConversationRequest.content)
}
#if LANG_CXX11
inline void ConversationRequest::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ConversationRequest.content)
}
#endif
inline void ConversationRequest::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConversationRequest.content)
}
inline void ConversationRequest::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConversationRequest.content)
}
inline ::std::string* ConversationRequest::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:ConversationRequest.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConversationRequest::release_content() {
  // @@protoc_insertion_point(field_release:ConversationRequest.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConversationRequest::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:ConversationRequest.content)
}

// required bytes signature = 5;
inline bool ConversationRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConversationRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConversationRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConversationRequest::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& ConversationRequest::signature() const {
  // @@protoc_insertion_point(field_get:ConversationRequest.signature)
  return signature_.GetNoArena();
}
inline void ConversationRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConversationRequest.signature)
}
#if LANG_CXX11
inline void ConversationRequest::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ConversationRequest.signature)
}
#endif
inline void ConversationRequest::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConversationRequest.signature)
}
inline void ConversationRequest::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConversationRequest.signature)
}
inline ::std::string* ConversationRequest::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:ConversationRequest.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConversationRequest::release_signature() {
  // @@protoc_insertion_point(field_release:ConversationRequest.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConversationRequest::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:ConversationRequest.signature)
}

// -------------------------------------------------------------------

// ConversationReply

// required uint32 session_id = 2;
inline bool ConversationReply::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConversationReply::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConversationReply::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConversationReply::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 ConversationReply::session_id() const {
  // @@protoc_insertion_point(field_get:ConversationReply.session_id)
  return session_id_;
}
inline void ConversationReply::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:ConversationReply.session_id)
}

// required uint32 message_id = 3;
inline bool ConversationReply::has_message_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConversationReply::set_has_message_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConversationReply::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConversationReply::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 ConversationReply::message_id() const {
  // @@protoc_insertion_point(field_get:ConversationReply.message_id)
  return message_id_;
}
inline void ConversationReply::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:ConversationReply.message_id)
}

// required bytes content = 4;
inline bool ConversationReply::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConversationReply::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConversationReply::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConversationReply::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& ConversationReply::content() const {
  // @@protoc_insertion_point(field_get:ConversationReply.content)
  return content_.GetNoArena();
}
inline void ConversationReply::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConversationReply.content)
}
#if LANG_CXX11
inline void ConversationReply::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ConversationReply.content)
}
#endif
inline void ConversationReply::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConversationReply.content)
}
inline void ConversationReply::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConversationReply.content)
}
inline ::std::string* ConversationReply::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:ConversationReply.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConversationReply::release_content() {
  // @@protoc_insertion_point(field_release:ConversationReply.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConversationReply::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:ConversationReply.content)
}

// required bytes signature = 5;
inline bool ConversationReply::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConversationReply::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConversationReply::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConversationReply::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& ConversationReply::signature() const {
  // @@protoc_insertion_point(field_get:ConversationReply.signature)
  return signature_.GetNoArena();
}
inline void ConversationReply::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConversationReply.signature)
}
#if LANG_CXX11
inline void ConversationReply::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ConversationReply.signature)
}
#endif
inline void ConversationReply::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConversationReply.signature)
}
inline void ConversationReply::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConversationReply.signature)
}
inline ::std::string* ConversationReply::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:ConversationReply.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConversationReply::release_signature() {
  // @@protoc_insertion_point(field_release:ConversationReply.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConversationReply::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:ConversationReply.signature)
}

// -------------------------------------------------------------------

// EndRequest

// -------------------------------------------------------------------

// EndReply

// -------------------------------------------------------------------

// CheckRequest

// -------------------------------------------------------------------

// CheckReply

// required int32 state = 2;
inline bool CheckReply::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckReply::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 CheckReply::state() const {
  // @@protoc_insertion_point(field_get:CheckReply.state)
  return state_;
}
inline void CheckReply::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:CheckReply.state)
}

// optional string dev_id = 3;
inline bool CheckReply::has_dev_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckReply::set_has_dev_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckReply::clear_has_dev_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckReply::clear_dev_id() {
  dev_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dev_id();
}
inline const ::std::string& CheckReply::dev_id() const {
  // @@protoc_insertion_point(field_get:CheckReply.dev_id)
  return dev_id_.GetNoArena();
}
inline void CheckReply::set_dev_id(const ::std::string& value) {
  set_has_dev_id();
  dev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CheckReply.dev_id)
}
#if LANG_CXX11
inline void CheckReply::set_dev_id(::std::string&& value) {
  set_has_dev_id();
  dev_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CheckReply.dev_id)
}
#endif
inline void CheckReply::set_dev_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dev_id();
  dev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CheckReply.dev_id)
}
inline void CheckReply::set_dev_id(const char* value, size_t size) {
  set_has_dev_id();
  dev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CheckReply.dev_id)
}
inline ::std::string* CheckReply::mutable_dev_id() {
  set_has_dev_id();
  // @@protoc_insertion_point(field_mutable:CheckReply.dev_id)
  return dev_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckReply::release_dev_id() {
  // @@protoc_insertion_point(field_release:CheckReply.dev_id)
  clear_has_dev_id();
  return dev_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckReply::set_allocated_dev_id(::std::string* dev_id) {
  if (dev_id != NULL) {
    set_has_dev_id();
  } else {
    clear_has_dev_id();
  }
  dev_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dev_id);
  // @@protoc_insertion_point(field_set_allocated:CheckReply.dev_id)
}

// -------------------------------------------------------------------

// InitRequest

// required string password = 2 [(.nanopb) = {
inline bool InitRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& InitRequest::password() const {
  // @@protoc_insertion_point(field_get:InitRequest.password)
  return password_.GetNoArena();
}
inline void InitRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitRequest.password)
}
#if LANG_CXX11
inline void InitRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitRequest.password)
}
#endif
inline void InitRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitRequest.password)
}
inline void InitRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitRequest.password)
}
inline ::std::string* InitRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:InitRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitRequest::release_password() {
  // @@protoc_insertion_point(field_release:InitRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:InitRequest.password)
}

// -------------------------------------------------------------------

// InitReply

// required bytes dev_id = 2 [(.nanopb) = {
inline bool InitReply::has_dev_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitReply::set_has_dev_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitReply::clear_has_dev_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitReply::clear_dev_id() {
  dev_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dev_id();
}
inline const ::std::string& InitReply::dev_id() const {
  // @@protoc_insertion_point(field_get:InitReply.dev_id)
  return dev_id_.GetNoArena();
}
inline void InitReply::set_dev_id(const ::std::string& value) {
  set_has_dev_id();
  dev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitReply.dev_id)
}
#if LANG_CXX11
inline void InitReply::set_dev_id(::std::string&& value) {
  set_has_dev_id();
  dev_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitReply.dev_id)
}
#endif
inline void InitReply::set_dev_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dev_id();
  dev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitReply.dev_id)
}
inline void InitReply::set_dev_id(const void* value, size_t size) {
  set_has_dev_id();
  dev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitReply.dev_id)
}
inline ::std::string* InitReply::mutable_dev_id() {
  set_has_dev_id();
  // @@protoc_insertion_point(field_mutable:InitReply.dev_id)
  return dev_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitReply::release_dev_id() {
  // @@protoc_insertion_point(field_release:InitReply.dev_id)
  clear_has_dev_id();
  return dev_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitReply::set_allocated_dev_id(::std::string* dev_id) {
  if (dev_id != NULL) {
    set_has_dev_id();
  } else {
    clear_has_dev_id();
  }
  dev_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dev_id);
  // @@protoc_insertion_point(field_set_allocated:InitReply.dev_id)
}

// -------------------------------------------------------------------

// PingRequest

// -------------------------------------------------------------------

// PingReply

// required int64 timestamp = 2;
inline bool PingReply::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingReply::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingReply::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingReply::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 PingReply::timestamp() const {
  // @@protoc_insertion_point(field_get:PingReply.timestamp)
  return timestamp_;
}
inline void PingReply::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:PingReply.timestamp)
}

// -------------------------------------------------------------------

// AddCoinRequest

// required uint32 type = 2;
inline bool AddCoinRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddCoinRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddCoinRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddCoinRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 AddCoinRequest::type() const {
  // @@protoc_insertion_point(field_get:AddCoinRequest.type)
  return type_;
}
inline void AddCoinRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AddCoinRequest.type)
}

// required uint32 idx = 3;
inline bool AddCoinRequest::has_idx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddCoinRequest::set_has_idx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddCoinRequest::clear_has_idx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddCoinRequest::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 AddCoinRequest::idx() const {
  // @@protoc_insertion_point(field_get:AddCoinRequest.idx)
  return idx_;
}
inline void AddCoinRequest::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:AddCoinRequest.idx)
}

// required string symbol = 4;
inline bool AddCoinRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddCoinRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddCoinRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddCoinRequest::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& AddCoinRequest::symbol() const {
  // @@protoc_insertion_point(field_get:AddCoinRequest.symbol)
  return symbol_.GetNoArena();
}
inline void AddCoinRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AddCoinRequest.symbol)
}
#if LANG_CXX11
inline void AddCoinRequest::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AddCoinRequest.symbol)
}
#endif
inline void AddCoinRequest::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AddCoinRequest.symbol)
}
inline void AddCoinRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AddCoinRequest.symbol)
}
inline ::std::string* AddCoinRequest::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:AddCoinRequest.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddCoinRequest::release_symbol() {
  // @@protoc_insertion_point(field_release:AddCoinRequest.symbol)
  clear_has_symbol();
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddCoinRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:AddCoinRequest.symbol)
}

// required string name = 5;
inline bool AddCoinRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddCoinRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddCoinRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddCoinRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& AddCoinRequest::name() const {
  // @@protoc_insertion_point(field_get:AddCoinRequest.name)
  return name_.GetNoArena();
}
inline void AddCoinRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AddCoinRequest.name)
}
#if LANG_CXX11
inline void AddCoinRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AddCoinRequest.name)
}
#endif
inline void AddCoinRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AddCoinRequest.name)
}
inline void AddCoinRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AddCoinRequest.name)
}
inline ::std::string* AddCoinRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:AddCoinRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddCoinRequest::release_name() {
  // @@protoc_insertion_point(field_release:AddCoinRequest.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddCoinRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:AddCoinRequest.name)
}

// -------------------------------------------------------------------

// AddCoinReply

// -------------------------------------------------------------------

// CreateAddressRequest

// required string password = 1 [(.nanopb) = {
inline bool CreateAddressRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateAddressRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateAddressRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateAddressRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& CreateAddressRequest::password() const {
  // @@protoc_insertion_point(field_get:CreateAddressRequest.password)
  return password_.GetNoArena();
}
inline void CreateAddressRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateAddressRequest.password)
}
#if LANG_CXX11
inline void CreateAddressRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateAddressRequest.password)
}
#endif
inline void CreateAddressRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateAddressRequest.password)
}
inline void CreateAddressRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateAddressRequest.password)
}
inline ::std::string* CreateAddressRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:CreateAddressRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAddressRequest::release_password() {
  // @@protoc_insertion_point(field_release:CreateAddressRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAddressRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:CreateAddressRequest.password)
}

// required uint32 type = 2;
inline bool CreateAddressRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateAddressRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateAddressRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateAddressRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CreateAddressRequest::type() const {
  // @@protoc_insertion_point(field_get:CreateAddressRequest.type)
  return type_;
}
inline void CreateAddressRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CreateAddressRequest.type)
}

// optional uint32 idx = 3;
inline bool CreateAddressRequest::has_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateAddressRequest::set_has_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateAddressRequest::clear_has_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateAddressRequest::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 CreateAddressRequest::idx() const {
  // @@protoc_insertion_point(field_get:CreateAddressRequest.idx)
  return idx_;
}
inline void CreateAddressRequest::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:CreateAddressRequest.idx)
}

// -------------------------------------------------------------------

// CreateAddressReply

// required uint32 type = 1;
inline bool CreateAddressReply::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateAddressReply::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateAddressReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateAddressReply::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CreateAddressReply::type() const {
  // @@protoc_insertion_point(field_get:CreateAddressReply.type)
  return type_;
}
inline void CreateAddressReply::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CreateAddressReply.type)
}

// required uint32 idx = 2;
inline bool CreateAddressReply::has_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateAddressReply::set_has_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateAddressReply::clear_has_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateAddressReply::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 CreateAddressReply::idx() const {
  // @@protoc_insertion_point(field_get:CreateAddressReply.idx)
  return idx_;
}
inline void CreateAddressReply::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:CreateAddressReply.idx)
}

// required string address = 3 [(.nanopb) = {
inline bool CreateAddressReply::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateAddressReply::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateAddressReply::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateAddressReply::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& CreateAddressReply::address() const {
  // @@protoc_insertion_point(field_get:CreateAddressReply.address)
  return address_.GetNoArena();
}
inline void CreateAddressReply::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateAddressReply.address)
}
#if LANG_CXX11
inline void CreateAddressReply::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateAddressReply.address)
}
#endif
inline void CreateAddressReply::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateAddressReply.address)
}
inline void CreateAddressReply::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateAddressReply.address)
}
inline ::std::string* CreateAddressReply::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:CreateAddressReply.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAddressReply::release_address() {
  // @@protoc_insertion_point(field_release:CreateAddressReply.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAddressReply::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:CreateAddressReply.address)
}

// -------------------------------------------------------------------

// CreateSecretRequest

// required string password = 1 [(.nanopb) = {
inline bool CreateSecretRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSecretRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSecretRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSecretRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& CreateSecretRequest::password() const {
  // @@protoc_insertion_point(field_get:CreateSecretRequest.password)
  return password_.GetNoArena();
}
inline void CreateSecretRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateSecretRequest.password)
}
#if LANG_CXX11
inline void CreateSecretRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateSecretRequest.password)
}
#endif
inline void CreateSecretRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateSecretRequest.password)
}
inline void CreateSecretRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateSecretRequest.password)
}
inline ::std::string* CreateSecretRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:CreateSecretRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateSecretRequest::release_password() {
  // @@protoc_insertion_point(field_release:CreateSecretRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateSecretRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:CreateSecretRequest.password)
}

// required uint32 type = 2;
inline bool CreateSecretRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSecretRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSecretRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSecretRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CreateSecretRequest::type() const {
  // @@protoc_insertion_point(field_get:CreateSecretRequest.type)
  return type_;
}
inline void CreateSecretRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CreateSecretRequest.type)
}

// required uint32 site = 3;
inline bool CreateSecretRequest::has_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateSecretRequest::set_has_site() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateSecretRequest::clear_has_site() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateSecretRequest::clear_site() {
  site_ = 0u;
  clear_has_site();
}
inline ::google::protobuf::uint32 CreateSecretRequest::site() const {
  // @@protoc_insertion_point(field_get:CreateSecretRequest.site)
  return site_;
}
inline void CreateSecretRequest::set_site(::google::protobuf::uint32 value) {
  set_has_site();
  site_ = value;
  // @@protoc_insertion_point(field_set:CreateSecretRequest.site)
}

// required uint32 account = 4;
inline bool CreateSecretRequest::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateSecretRequest::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateSecretRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateSecretRequest::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 CreateSecretRequest::account() const {
  // @@protoc_insertion_point(field_get:CreateSecretRequest.account)
  return account_;
}
inline void CreateSecretRequest::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:CreateSecretRequest.account)
}

// -------------------------------------------------------------------

// CreateSecretReply

// required uint32 type = 1;
inline bool CreateSecretReply::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSecretReply::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSecretReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSecretReply::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CreateSecretReply::type() const {
  // @@protoc_insertion_point(field_get:CreateSecretReply.type)
  return type_;
}
inline void CreateSecretReply::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CreateSecretReply.type)
}

// required uint32 site = 2;
inline bool CreateSecretReply::has_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateSecretReply::set_has_site() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateSecretReply::clear_has_site() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateSecretReply::clear_site() {
  site_ = 0u;
  clear_has_site();
}
inline ::google::protobuf::uint32 CreateSecretReply::site() const {
  // @@protoc_insertion_point(field_get:CreateSecretReply.site)
  return site_;
}
inline void CreateSecretReply::set_site(::google::protobuf::uint32 value) {
  set_has_site();
  site_ = value;
  // @@protoc_insertion_point(field_set:CreateSecretReply.site)
}

// required uint32 account = 3;
inline bool CreateSecretReply::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateSecretReply::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateSecretReply::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateSecretReply::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 CreateSecretReply::account() const {
  // @@protoc_insertion_point(field_get:CreateSecretReply.account)
  return account_;
}
inline void CreateSecretReply::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:CreateSecretReply.account)
}

// required uint32 index = 4;
inline bool CreateSecretReply::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateSecretReply::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateSecretReply::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateSecretReply::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CreateSecretReply::index() const {
  // @@protoc_insertion_point(field_get:CreateSecretReply.index)
  return index_;
}
inline void CreateSecretReply::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:CreateSecretReply.index)
}

// required bytes secret = 5 [(.nanopb) = {
inline bool CreateSecretReply::has_secret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSecretReply::set_has_secret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSecretReply::clear_has_secret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSecretReply::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret();
}
inline const ::std::string& CreateSecretReply::secret() const {
  // @@protoc_insertion_point(field_get:CreateSecretReply.secret)
  return secret_.GetNoArena();
}
inline void CreateSecretReply::set_secret(const ::std::string& value) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateSecretReply.secret)
}
#if LANG_CXX11
inline void CreateSecretReply::set_secret(::std::string&& value) {
  set_has_secret();
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateSecretReply.secret)
}
#endif
inline void CreateSecretReply::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateSecretReply.secret)
}
inline void CreateSecretReply::set_secret(const void* value, size_t size) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateSecretReply.secret)
}
inline ::std::string* CreateSecretReply::mutable_secret() {
  set_has_secret();
  // @@protoc_insertion_point(field_mutable:CreateSecretReply.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateSecretReply::release_secret() {
  // @@protoc_insertion_point(field_release:CreateSecretReply.secret)
  clear_has_secret();
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateSecretReply::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:CreateSecretReply.secret)
}

// -------------------------------------------------------------------

// AddSecretRequest

// required string password = 1 [(.nanopb) = {
inline bool AddSecretRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddSecretRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddSecretRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddSecretRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& AddSecretRequest::password() const {
  // @@protoc_insertion_point(field_get:AddSecretRequest.password)
  return password_.GetNoArena();
}
inline void AddSecretRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AddSecretRequest.password)
}
#if LANG_CXX11
inline void AddSecretRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AddSecretRequest.password)
}
#endif
inline void AddSecretRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AddSecretRequest.password)
}
inline void AddSecretRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AddSecretRequest.password)
}
inline ::std::string* AddSecretRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:AddSecretRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddSecretRequest::release_password() {
  // @@protoc_insertion_point(field_release:AddSecretRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddSecretRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:AddSecretRequest.password)
}

// required uint32 type = 2;
inline bool AddSecretRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddSecretRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddSecretRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddSecretRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 AddSecretRequest::type() const {
  // @@protoc_insertion_point(field_get:AddSecretRequest.type)
  return type_;
}
inline void AddSecretRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AddSecretRequest.type)
}

// required uint32 site = 3;
inline bool AddSecretRequest::has_site() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddSecretRequest::set_has_site() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddSecretRequest::clear_has_site() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddSecretRequest::clear_site() {
  site_ = 0u;
  clear_has_site();
}
inline ::google::protobuf::uint32 AddSecretRequest::site() const {
  // @@protoc_insertion_point(field_get:AddSecretRequest.site)
  return site_;
}
inline void AddSecretRequest::set_site(::google::protobuf::uint32 value) {
  set_has_site();
  site_ = value;
  // @@protoc_insertion_point(field_set:AddSecretRequest.site)
}

// required uint32 account = 4;
inline bool AddSecretRequest::has_account() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddSecretRequest::set_has_account() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddSecretRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddSecretRequest::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 AddSecretRequest::account() const {
  // @@protoc_insertion_point(field_get:AddSecretRequest.account)
  return account_;
}
inline void AddSecretRequest::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:AddSecretRequest.account)
}

// required bytes secret = 5 [(.nanopb) = {
inline bool AddSecretRequest::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddSecretRequest::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddSecretRequest::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddSecretRequest::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret();
}
inline const ::std::string& AddSecretRequest::secret() const {
  // @@protoc_insertion_point(field_get:AddSecretRequest.secret)
  return secret_.GetNoArena();
}
inline void AddSecretRequest::set_secret(const ::std::string& value) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AddSecretRequest.secret)
}
#if LANG_CXX11
inline void AddSecretRequest::set_secret(::std::string&& value) {
  set_has_secret();
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AddSecretRequest.secret)
}
#endif
inline void AddSecretRequest::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AddSecretRequest.secret)
}
inline void AddSecretRequest::set_secret(const void* value, size_t size) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AddSecretRequest.secret)
}
inline ::std::string* AddSecretRequest::mutable_secret() {
  set_has_secret();
  // @@protoc_insertion_point(field_mutable:AddSecretRequest.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddSecretRequest::release_secret() {
  // @@protoc_insertion_point(field_release:AddSecretRequest.secret)
  clear_has_secret();
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddSecretRequest::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:AddSecretRequest.secret)
}

// -------------------------------------------------------------------

// AddSecretReply

// required uint32 type = 1;
inline bool AddSecretReply::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddSecretReply::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddSecretReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddSecretReply::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 AddSecretReply::type() const {
  // @@protoc_insertion_point(field_get:AddSecretReply.type)
  return type_;
}
inline void AddSecretReply::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AddSecretReply.type)
}

// required uint32 site = 2;
inline bool AddSecretReply::has_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddSecretReply::set_has_site() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddSecretReply::clear_has_site() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddSecretReply::clear_site() {
  site_ = 0u;
  clear_has_site();
}
inline ::google::protobuf::uint32 AddSecretReply::site() const {
  // @@protoc_insertion_point(field_get:AddSecretReply.site)
  return site_;
}
inline void AddSecretReply::set_site(::google::protobuf::uint32 value) {
  set_has_site();
  site_ = value;
  // @@protoc_insertion_point(field_set:AddSecretReply.site)
}

// required uint32 account = 3;
inline bool AddSecretReply::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddSecretReply::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddSecretReply::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddSecretReply::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 AddSecretReply::account() const {
  // @@protoc_insertion_point(field_get:AddSecretReply.account)
  return account_;
}
inline void AddSecretReply::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:AddSecretReply.account)
}

// required uint32 idx = 4;
inline bool AddSecretReply::has_idx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddSecretReply::set_has_idx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddSecretReply::clear_has_idx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddSecretReply::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 AddSecretReply::idx() const {
  // @@protoc_insertion_point(field_get:AddSecretReply.idx)
  return idx_;
}
inline void AddSecretReply::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:AddSecretReply.idx)
}

// required bytes secret = 5 [(.nanopb) = {
inline bool AddSecretReply::has_secret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddSecretReply::set_has_secret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddSecretReply::clear_has_secret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddSecretReply::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret();
}
inline const ::std::string& AddSecretReply::secret() const {
  // @@protoc_insertion_point(field_get:AddSecretReply.secret)
  return secret_.GetNoArena();
}
inline void AddSecretReply::set_secret(const ::std::string& value) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AddSecretReply.secret)
}
#if LANG_CXX11
inline void AddSecretReply::set_secret(::std::string&& value) {
  set_has_secret();
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AddSecretReply.secret)
}
#endif
inline void AddSecretReply::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AddSecretReply.secret)
}
inline void AddSecretReply::set_secret(const void* value, size_t size) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AddSecretReply.secret)
}
inline ::std::string* AddSecretReply::mutable_secret() {
  set_has_secret();
  // @@protoc_insertion_point(field_mutable:AddSecretReply.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddSecretReply::release_secret() {
  // @@protoc_insertion_point(field_release:AddSecretReply.secret)
  clear_has_secret();
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddSecretReply::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:AddSecretReply.secret)
}

// -------------------------------------------------------------------

// SignTxRequest

// required string password = 1;
inline bool SignTxRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignTxRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignTxRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignTxRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& SignTxRequest::password() const {
  // @@protoc_insertion_point(field_get:SignTxRequest.password)
  return password_.GetNoArena();
}
inline void SignTxRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignTxRequest.password)
}
#if LANG_CXX11
inline void SignTxRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignTxRequest.password)
}
#endif
inline void SignTxRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignTxRequest.password)
}
inline void SignTxRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignTxRequest.password)
}
inline ::std::string* SignTxRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:SignTxRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignTxRequest::release_password() {
  // @@protoc_insertion_point(field_release:SignTxRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignTxRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:SignTxRequest.password)
}

// required uint32 type = 2;
inline bool SignTxRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignTxRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignTxRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignTxRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SignTxRequest::type() const {
  // @@protoc_insertion_point(field_get:SignTxRequest.type)
  return type_;
}
inline void SignTxRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SignTxRequest.type)
}

// required uint32 idx = 3;
inline bool SignTxRequest::has_idx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignTxRequest::set_has_idx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignTxRequest::clear_has_idx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignTxRequest::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 SignTxRequest::idx() const {
  // @@protoc_insertion_point(field_get:SignTxRequest.idx)
  return idx_;
}
inline void SignTxRequest::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:SignTxRequest.idx)
}

// required uint64 amount = 4;
inline bool SignTxRequest::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignTxRequest::set_has_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignTxRequest::clear_has_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignTxRequest::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 SignTxRequest::amount() const {
  // @@protoc_insertion_point(field_get:SignTxRequest.amount)
  return amount_;
}
inline void SignTxRequest::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:SignTxRequest.amount)
}

// required string dest = 5 [(.nanopb) = {
inline bool SignTxRequest::has_dest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignTxRequest::set_has_dest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignTxRequest::clear_has_dest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignTxRequest::clear_dest() {
  dest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dest();
}
inline const ::std::string& SignTxRequest::dest() const {
  // @@protoc_insertion_point(field_get:SignTxRequest.dest)
  return dest_.GetNoArena();
}
inline void SignTxRequest::set_dest(const ::std::string& value) {
  set_has_dest();
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignTxRequest.dest)
}
#if LANG_CXX11
inline void SignTxRequest::set_dest(::std::string&& value) {
  set_has_dest();
  dest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignTxRequest.dest)
}
#endif
inline void SignTxRequest::set_dest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dest();
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignTxRequest.dest)
}
inline void SignTxRequest::set_dest(const char* value, size_t size) {
  set_has_dest();
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignTxRequest.dest)
}
inline ::std::string* SignTxRequest::mutable_dest() {
  set_has_dest();
  // @@protoc_insertion_point(field_mutable:SignTxRequest.dest)
  return dest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignTxRequest::release_dest() {
  // @@protoc_insertion_point(field_release:SignTxRequest.dest)
  clear_has_dest();
  return dest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignTxRequest::set_allocated_dest(::std::string* dest) {
  if (dest != NULL) {
    set_has_dest();
  } else {
    clear_has_dest();
  }
  dest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest);
  // @@protoc_insertion_point(field_set_allocated:SignTxRequest.dest)
}

// required bytes tx_hash = 6 [(.nanopb) = {
inline bool SignTxRequest::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignTxRequest::set_has_tx_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignTxRequest::clear_has_tx_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignTxRequest::clear_tx_hash() {
  tx_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tx_hash();
}
inline const ::std::string& SignTxRequest::tx_hash() const {
  // @@protoc_insertion_point(field_get:SignTxRequest.tx_hash)
  return tx_hash_.GetNoArena();
}
inline void SignTxRequest::set_tx_hash(const ::std::string& value) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignTxRequest.tx_hash)
}
#if LANG_CXX11
inline void SignTxRequest::set_tx_hash(::std::string&& value) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignTxRequest.tx_hash)
}
#endif
inline void SignTxRequest::set_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignTxRequest.tx_hash)
}
inline void SignTxRequest::set_tx_hash(const void* value, size_t size) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignTxRequest.tx_hash)
}
inline ::std::string* SignTxRequest::mutable_tx_hash() {
  set_has_tx_hash();
  // @@protoc_insertion_point(field_mutable:SignTxRequest.tx_hash)
  return tx_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignTxRequest::release_tx_hash() {
  // @@protoc_insertion_point(field_release:SignTxRequest.tx_hash)
  clear_has_tx_hash();
  return tx_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignTxRequest::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash != NULL) {
    set_has_tx_hash();
  } else {
    clear_has_tx_hash();
  }
  tx_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_hash);
  // @@protoc_insertion_point(field_set_allocated:SignTxRequest.tx_hash)
}

// required uint32 tx_idx = 7;
inline bool SignTxRequest::has_tx_idx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignTxRequest::set_has_tx_idx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignTxRequest::clear_has_tx_idx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignTxRequest::clear_tx_idx() {
  tx_idx_ = 0u;
  clear_has_tx_idx();
}
inline ::google::protobuf::uint32 SignTxRequest::tx_idx() const {
  // @@protoc_insertion_point(field_get:SignTxRequest.tx_idx)
  return tx_idx_;
}
inline void SignTxRequest::set_tx_idx(::google::protobuf::uint32 value) {
  set_has_tx_idx();
  tx_idx_ = value;
  // @@protoc_insertion_point(field_set:SignTxRequest.tx_idx)
}

// -------------------------------------------------------------------

// SignTxReply

// required bytes signedTx = 2 [(.nanopb) = {
inline bool SignTxReply::has_signedtx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignTxReply::set_has_signedtx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignTxReply::clear_has_signedtx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignTxReply::clear_signedtx() {
  signedtx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signedtx();
}
inline const ::std::string& SignTxReply::signedtx() const {
  // @@protoc_insertion_point(field_get:SignTxReply.signedTx)
  return signedtx_.GetNoArena();
}
inline void SignTxReply::set_signedtx(const ::std::string& value) {
  set_has_signedtx();
  signedtx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignTxReply.signedTx)
}
#if LANG_CXX11
inline void SignTxReply::set_signedtx(::std::string&& value) {
  set_has_signedtx();
  signedtx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignTxReply.signedTx)
}
#endif
inline void SignTxReply::set_signedtx(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signedtx();
  signedtx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignTxReply.signedTx)
}
inline void SignTxReply::set_signedtx(const void* value, size_t size) {
  set_has_signedtx();
  signedtx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignTxReply.signedTx)
}
inline ::std::string* SignTxReply::mutable_signedtx() {
  set_has_signedtx();
  // @@protoc_insertion_point(field_mutable:SignTxReply.signedTx)
  return signedtx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignTxReply::release_signedtx() {
  // @@protoc_insertion_point(field_release:SignTxReply.signedTx)
  clear_has_signedtx();
  return signedtx_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignTxReply::set_allocated_signedtx(::std::string* signedtx) {
  if (signedtx != NULL) {
    set_has_signedtx();
  } else {
    clear_has_signedtx();
  }
  signedtx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signedtx);
  // @@protoc_insertion_point(field_set_allocated:SignTxReply.signedTx)
}

// -------------------------------------------------------------------

// SignMsgRequest

// required string password = 1;
inline bool SignMsgRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignMsgRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignMsgRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignMsgRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& SignMsgRequest::password() const {
  // @@protoc_insertion_point(field_get:SignMsgRequest.password)
  return password_.GetNoArena();
}
inline void SignMsgRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignMsgRequest.password)
}
#if LANG_CXX11
inline void SignMsgRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignMsgRequest.password)
}
#endif
inline void SignMsgRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignMsgRequest.password)
}
inline void SignMsgRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignMsgRequest.password)
}
inline ::std::string* SignMsgRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:SignMsgRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignMsgRequest::release_password() {
  // @@protoc_insertion_point(field_release:SignMsgRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignMsgRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:SignMsgRequest.password)
}

// required uint32 type = 2;
inline bool SignMsgRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignMsgRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignMsgRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignMsgRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SignMsgRequest::type() const {
  // @@protoc_insertion_point(field_get:SignMsgRequest.type)
  return type_;
}
inline void SignMsgRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SignMsgRequest.type)
}

// required uint32 idx = 3;
inline bool SignMsgRequest::has_idx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignMsgRequest::set_has_idx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignMsgRequest::clear_has_idx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignMsgRequest::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 SignMsgRequest::idx() const {
  // @@protoc_insertion_point(field_get:SignMsgRequest.idx)
  return idx_;
}
inline void SignMsgRequest::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:SignMsgRequest.idx)
}

// required bytes message = 4;
inline bool SignMsgRequest::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignMsgRequest::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignMsgRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignMsgRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& SignMsgRequest::message() const {
  // @@protoc_insertion_point(field_get:SignMsgRequest.message)
  return message_.GetNoArena();
}
inline void SignMsgRequest::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignMsgRequest.message)
}
#if LANG_CXX11
inline void SignMsgRequest::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignMsgRequest.message)
}
#endif
inline void SignMsgRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignMsgRequest.message)
}
inline void SignMsgRequest::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignMsgRequest.message)
}
inline ::std::string* SignMsgRequest::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:SignMsgRequest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignMsgRequest::release_message() {
  // @@protoc_insertion_point(field_release:SignMsgRequest.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignMsgRequest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SignMsgRequest.message)
}

// -------------------------------------------------------------------

// SignMsgReply

// required bytes signed = 1 [(.nanopb) = {
inline bool SignMsgReply::has_signed_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignMsgReply::set_has_signed_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignMsgReply::clear_has_signed_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignMsgReply::clear_signed_() {
  signed__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signed_();
}
inline const ::std::string& SignMsgReply::signed_() const {
  // @@protoc_insertion_point(field_get:SignMsgReply.signed)
  return signed__.GetNoArena();
}
inline void SignMsgReply::set_signed_(const ::std::string& value) {
  set_has_signed_();
  signed__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignMsgReply.signed)
}
#if LANG_CXX11
inline void SignMsgReply::set_signed_(::std::string&& value) {
  set_has_signed_();
  signed__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignMsgReply.signed)
}
#endif
inline void SignMsgReply::set_signed_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signed_();
  signed__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignMsgReply.signed)
}
inline void SignMsgReply::set_signed_(const void* value, size_t size) {
  set_has_signed_();
  signed__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignMsgReply.signed)
}
inline ::std::string* SignMsgReply::mutable_signed_() {
  set_has_signed_();
  // @@protoc_insertion_point(field_mutable:SignMsgReply.signed)
  return signed__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignMsgReply::release_signed_() {
  // @@protoc_insertion_point(field_release:SignMsgReply.signed)
  clear_has_signed_();
  return signed__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignMsgReply::set_allocated_signed_(::std::string* signed_) {
  if (signed_ != NULL) {
    set_has_signed_();
  } else {
    clear_has_signed_();
  }
  signed__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signed_);
  // @@protoc_insertion_point(field_set_allocated:SignMsgReply.signed)
}

// -------------------------------------------------------------------

// ListCoinRequest

// -------------------------------------------------------------------

// ListCoinReply

// required uint32 max = 2;
inline bool ListCoinReply::has_max() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListCoinReply::set_has_max() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListCoinReply::clear_has_max() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListCoinReply::clear_max() {
  max_ = 0u;
  clear_has_max();
}
inline ::google::protobuf::uint32 ListCoinReply::max() const {
  // @@protoc_insertion_point(field_get:ListCoinReply.max)
  return max_;
}
inline void ListCoinReply::set_max(::google::protobuf::uint32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:ListCoinReply.max)
}

// repeated uint32 type = 3 [(.nanopb) = {
inline int ListCoinReply::type_size() const {
  return type_.size();
}
inline void ListCoinReply::clear_type() {
  type_.Clear();
}
inline ::google::protobuf::uint32 ListCoinReply::type(int index) const {
  // @@protoc_insertion_point(field_get:ListCoinReply.type)
  return type_.Get(index);
}
inline void ListCoinReply::set_type(int index, ::google::protobuf::uint32 value) {
  type_.Set(index, value);
  // @@protoc_insertion_point(field_set:ListCoinReply.type)
}
inline void ListCoinReply::add_type(::google::protobuf::uint32 value) {
  type_.Add(value);
  // @@protoc_insertion_point(field_add:ListCoinReply.type)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ListCoinReply::type() const {
  // @@protoc_insertion_point(field_list:ListCoinReply.type)
  return type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ListCoinReply::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:ListCoinReply.type)
  return &type_;
}

// -------------------------------------------------------------------

// GetAddressRequest

// required string password = 1;
inline bool GetAddressRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAddressRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAddressRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAddressRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& GetAddressRequest::password() const {
  // @@protoc_insertion_point(field_get:GetAddressRequest.password)
  return password_.GetNoArena();
}
inline void GetAddressRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GetAddressRequest.password)
}
#if LANG_CXX11
inline void GetAddressRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GetAddressRequest.password)
}
#endif
inline void GetAddressRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GetAddressRequest.password)
}
inline void GetAddressRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GetAddressRequest.password)
}
inline ::std::string* GetAddressRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:GetAddressRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAddressRequest::release_password() {
  // @@protoc_insertion_point(field_release:GetAddressRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAddressRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:GetAddressRequest.password)
}

// required uint32 type = 2;
inline bool GetAddressRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAddressRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAddressRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAddressRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 GetAddressRequest::type() const {
  // @@protoc_insertion_point(field_get:GetAddressRequest.type)
  return type_;
}
inline void GetAddressRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GetAddressRequest.type)
}

// required uint32 idx = 3;
inline bool GetAddressRequest::has_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAddressRequest::set_has_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAddressRequest::clear_has_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAddressRequest::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 GetAddressRequest::idx() const {
  // @@protoc_insertion_point(field_get:GetAddressRequest.idx)
  return idx_;
}
inline void GetAddressRequest::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:GetAddressRequest.idx)
}

// -------------------------------------------------------------------

// GetAddressReply

// required .Address addr = 1;
inline bool GetAddressReply::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAddressReply::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAddressReply::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAddressReply::clear_addr() {
  if (addr_ != NULL) addr_->::Address::Clear();
  clear_has_addr();
}
inline const ::Address& GetAddressReply::addr() const {
  const ::Address* p = addr_;
  // @@protoc_insertion_point(field_get:GetAddressReply.addr)
  return p != NULL ? *p : *reinterpret_cast<const ::Address*>(
      &::_Address_default_instance_);
}
inline ::Address* GetAddressReply::mutable_addr() {
  set_has_addr();
  if (addr_ == NULL) {
    addr_ = new ::Address;
  }
  // @@protoc_insertion_point(field_mutable:GetAddressReply.addr)
  return addr_;
}
inline ::Address* GetAddressReply::release_addr() {
  // @@protoc_insertion_point(field_release:GetAddressReply.addr)
  clear_has_addr();
  ::Address* temp = addr_;
  addr_ = NULL;
  return temp;
}
inline void GetAddressReply::set_allocated_addr(::Address* addr) {
  delete addr_;
  addr_ = addr;
  if (addr) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  // @@protoc_insertion_point(field_set_allocated:GetAddressReply.addr)
}

// -------------------------------------------------------------------

// ListAddressRequest

// required string password = 1;
inline bool ListAddressRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListAddressRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListAddressRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListAddressRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& ListAddressRequest::password() const {
  // @@protoc_insertion_point(field_get:ListAddressRequest.password)
  return password_.GetNoArena();
}
inline void ListAddressRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ListAddressRequest.password)
}
#if LANG_CXX11
inline void ListAddressRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ListAddressRequest.password)
}
#endif
inline void ListAddressRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ListAddressRequest.password)
}
inline void ListAddressRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ListAddressRequest.password)
}
inline ::std::string* ListAddressRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:ListAddressRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListAddressRequest::release_password() {
  // @@protoc_insertion_point(field_release:ListAddressRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListAddressRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:ListAddressRequest.password)
}

// required uint32 type = 2;
inline bool ListAddressRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListAddressRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListAddressRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListAddressRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ListAddressRequest::type() const {
  // @@protoc_insertion_point(field_get:ListAddressRequest.type)
  return type_;
}
inline void ListAddressRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ListAddressRequest.type)
}

// required uint32 offset = 3;
inline bool ListAddressRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListAddressRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListAddressRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListAddressRequest::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 ListAddressRequest::offset() const {
  // @@protoc_insertion_point(field_get:ListAddressRequest.offset)
  return offset_;
}
inline void ListAddressRequest::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:ListAddressRequest.offset)
}

// required uint32 limit = 4;
inline bool ListAddressRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListAddressRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListAddressRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListAddressRequest::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 ListAddressRequest::limit() const {
  // @@protoc_insertion_point(field_get:ListAddressRequest.limit)
  return limit_;
}
inline void ListAddressRequest::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:ListAddressRequest.limit)
}

// -------------------------------------------------------------------

// Address

// required uint32 type = 1;
inline bool Address::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Address::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Address::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Address::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Address::type() const {
  // @@protoc_insertion_point(field_get:Address.type)
  return type_;
}
inline void Address::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Address.type)
}

// required uint32 idx = 2;
inline bool Address::has_idx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Address::set_has_idx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Address::clear_has_idx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Address::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 Address::idx() const {
  // @@protoc_insertion_point(field_get:Address.idx)
  return idx_;
}
inline void Address::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:Address.idx)
}

// optional string name = 3;
inline bool Address::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Address::name() const {
  // @@protoc_insertion_point(field_get:Address.name)
  return name_.GetNoArena();
}
inline void Address::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Address.name)
}
#if LANG_CXX11
inline void Address::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Address.name)
}
#endif
inline void Address::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Address.name)
}
inline void Address::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Address.name)
}
inline ::std::string* Address::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Address.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_name() {
  // @@protoc_insertion_point(field_release:Address.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Address.name)
}

// required string s_addr = 4 [(.nanopb) = {
inline bool Address::has_s_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_s_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_s_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_s_addr() {
  s_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s_addr();
}
inline const ::std::string& Address::s_addr() const {
  // @@protoc_insertion_point(field_get:Address.s_addr)
  return s_addr_.GetNoArena();
}
inline void Address::set_s_addr(const ::std::string& value) {
  set_has_s_addr();
  s_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Address.s_addr)
}
#if LANG_CXX11
inline void Address::set_s_addr(::std::string&& value) {
  set_has_s_addr();
  s_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Address.s_addr)
}
#endif
inline void Address::set_s_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s_addr();
  s_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Address.s_addr)
}
inline void Address::set_s_addr(const char* value, size_t size) {
  set_has_s_addr();
  s_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Address.s_addr)
}
inline ::std::string* Address::mutable_s_addr() {
  set_has_s_addr();
  // @@protoc_insertion_point(field_mutable:Address.s_addr)
  return s_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_s_addr() {
  // @@protoc_insertion_point(field_release:Address.s_addr)
  clear_has_s_addr();
  return s_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_s_addr(::std::string* s_addr) {
  if (s_addr != NULL) {
    set_has_s_addr();
  } else {
    clear_has_s_addr();
  }
  s_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s_addr);
  // @@protoc_insertion_point(field_set_allocated:Address.s_addr)
}

// -------------------------------------------------------------------

// ListAddressReply

// required uint32 total_records = 1;
inline bool ListAddressReply::has_total_records() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListAddressReply::set_has_total_records() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListAddressReply::clear_has_total_records() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListAddressReply::clear_total_records() {
  total_records_ = 0u;
  clear_has_total_records();
}
inline ::google::protobuf::uint32 ListAddressReply::total_records() const {
  // @@protoc_insertion_point(field_get:ListAddressReply.total_records)
  return total_records_;
}
inline void ListAddressReply::set_total_records(::google::protobuf::uint32 value) {
  set_has_total_records();
  total_records_ = value;
  // @@protoc_insertion_point(field_set:ListAddressReply.total_records)
}

// required uint32 total_pages = 2;
inline bool ListAddressReply::has_total_pages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListAddressReply::set_has_total_pages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListAddressReply::clear_has_total_pages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListAddressReply::clear_total_pages() {
  total_pages_ = 0u;
  clear_has_total_pages();
}
inline ::google::protobuf::uint32 ListAddressReply::total_pages() const {
  // @@protoc_insertion_point(field_get:ListAddressReply.total_pages)
  return total_pages_;
}
inline void ListAddressReply::set_total_pages(::google::protobuf::uint32 value) {
  set_has_total_pages();
  total_pages_ = value;
  // @@protoc_insertion_point(field_set:ListAddressReply.total_pages)
}

// required uint32 limit = 3;
inline bool ListAddressReply::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListAddressReply::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListAddressReply::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListAddressReply::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 ListAddressReply::limit() const {
  // @@protoc_insertion_point(field_get:ListAddressReply.limit)
  return limit_;
}
inline void ListAddressReply::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:ListAddressReply.limit)
}

// required uint32 offset = 4;
inline bool ListAddressReply::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListAddressReply::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListAddressReply::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListAddressReply::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 ListAddressReply::offset() const {
  // @@protoc_insertion_point(field_get:ListAddressReply.offset)
  return offset_;
}
inline void ListAddressReply::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:ListAddressReply.offset)
}

// repeated .Address addr = 5 [(.nanopb) = {
inline int ListAddressReply::addr_size() const {
  return addr_.size();
}
inline void ListAddressReply::clear_addr() {
  addr_.Clear();
}
inline const ::Address& ListAddressReply::addr(int index) const {
  // @@protoc_insertion_point(field_get:ListAddressReply.addr)
  return addr_.Get(index);
}
inline ::Address* ListAddressReply::mutable_addr(int index) {
  // @@protoc_insertion_point(field_mutable:ListAddressReply.addr)
  return addr_.Mutable(index);
}
inline ::Address* ListAddressReply::add_addr() {
  // @@protoc_insertion_point(field_add:ListAddressReply.addr)
  return addr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Address >*
ListAddressReply::mutable_addr() {
  // @@protoc_insertion_point(field_mutable_list:ListAddressReply.addr)
  return &addr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Address >&
ListAddressReply::addr() const {
  // @@protoc_insertion_point(field_list:ListAddressReply.addr)
  return addr_;
}

// -------------------------------------------------------------------

// ListSecretRequest

// required string password = 1;
inline bool ListSecretRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSecretRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSecretRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSecretRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& ListSecretRequest::password() const {
  // @@protoc_insertion_point(field_get:ListSecretRequest.password)
  return password_.GetNoArena();
}
inline void ListSecretRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ListSecretRequest.password)
}
#if LANG_CXX11
inline void ListSecretRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ListSecretRequest.password)
}
#endif
inline void ListSecretRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ListSecretRequest.password)
}
inline void ListSecretRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ListSecretRequest.password)
}
inline ::std::string* ListSecretRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:ListSecretRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListSecretRequest::release_password() {
  // @@protoc_insertion_point(field_release:ListSecretRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListSecretRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:ListSecretRequest.password)
}

// required uint32 type = 2;
inline bool ListSecretRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListSecretRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListSecretRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListSecretRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ListSecretRequest::type() const {
  // @@protoc_insertion_point(field_get:ListSecretRequest.type)
  return type_;
}
inline void ListSecretRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ListSecretRequest.type)
}

// optional uint32 site = 3;
inline bool ListSecretRequest::has_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListSecretRequest::set_has_site() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListSecretRequest::clear_has_site() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListSecretRequest::clear_site() {
  site_ = 0u;
  clear_has_site();
}
inline ::google::protobuf::uint32 ListSecretRequest::site() const {
  // @@protoc_insertion_point(field_get:ListSecretRequest.site)
  return site_;
}
inline void ListSecretRequest::set_site(::google::protobuf::uint32 value) {
  set_has_site();
  site_ = value;
  // @@protoc_insertion_point(field_set:ListSecretRequest.site)
}

// optional uint32 account = 4;
inline bool ListSecretRequest::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListSecretRequest::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListSecretRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListSecretRequest::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 ListSecretRequest::account() const {
  // @@protoc_insertion_point(field_get:ListSecretRequest.account)
  return account_;
}
inline void ListSecretRequest::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:ListSecretRequest.account)
}

// required uint32 offset = 5;
inline bool ListSecretRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListSecretRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListSecretRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListSecretRequest::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 ListSecretRequest::offset() const {
  // @@protoc_insertion_point(field_get:ListSecretRequest.offset)
  return offset_;
}
inline void ListSecretRequest::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:ListSecretRequest.offset)
}

// required uint32 limit = 6;
inline bool ListSecretRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ListSecretRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ListSecretRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ListSecretRequest::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 ListSecretRequest::limit() const {
  // @@protoc_insertion_point(field_get:ListSecretRequest.limit)
  return limit_;
}
inline void ListSecretRequest::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:ListSecretRequest.limit)
}

// -------------------------------------------------------------------

// Secret

// required uint32 type = 1;
inline bool Secret::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Secret::type() const {
  // @@protoc_insertion_point(field_get:Secret.type)
  return type_;
}
inline void Secret::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Secret.type)
}

// required uint32 site = 2;
inline bool Secret::has_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Secret::set_has_site() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Secret::clear_has_site() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Secret::clear_site() {
  site_ = 0u;
  clear_has_site();
}
inline ::google::protobuf::uint32 Secret::site() const {
  // @@protoc_insertion_point(field_get:Secret.site)
  return site_;
}
inline void Secret::set_site(::google::protobuf::uint32 value) {
  set_has_site();
  site_ = value;
  // @@protoc_insertion_point(field_set:Secret.site)
}

// required uint32 account = 3;
inline bool Secret::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Secret::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Secret::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Secret::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 Secret::account() const {
  // @@protoc_insertion_point(field_get:Secret.account)
  return account_;
}
inline void Secret::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:Secret.account)
}

// required uint32 idx = 4;
inline bool Secret::has_idx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Secret::set_has_idx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Secret::clear_has_idx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Secret::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 Secret::idx() const {
  // @@protoc_insertion_point(field_get:Secret.idx)
  return idx_;
}
inline void Secret::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:Secret.idx)
}

// required bytes s_secret = 5 [(.nanopb) = {
inline bool Secret::has_s_secret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret::set_has_s_secret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret::clear_has_s_secret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret::clear_s_secret() {
  s_secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s_secret();
}
inline const ::std::string& Secret::s_secret() const {
  // @@protoc_insertion_point(field_get:Secret.s_secret)
  return s_secret_.GetNoArena();
}
inline void Secret::set_s_secret(const ::std::string& value) {
  set_has_s_secret();
  s_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Secret.s_secret)
}
#if LANG_CXX11
inline void Secret::set_s_secret(::std::string&& value) {
  set_has_s_secret();
  s_secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Secret.s_secret)
}
#endif
inline void Secret::set_s_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s_secret();
  s_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Secret.s_secret)
}
inline void Secret::set_s_secret(const void* value, size_t size) {
  set_has_s_secret();
  s_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Secret.s_secret)
}
inline ::std::string* Secret::mutable_s_secret() {
  set_has_s_secret();
  // @@protoc_insertion_point(field_mutable:Secret.s_secret)
  return s_secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Secret::release_s_secret() {
  // @@protoc_insertion_point(field_release:Secret.s_secret)
  clear_has_s_secret();
  return s_secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Secret::set_allocated_s_secret(::std::string* s_secret) {
  if (s_secret != NULL) {
    set_has_s_secret();
  } else {
    clear_has_s_secret();
  }
  s_secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s_secret);
  // @@protoc_insertion_point(field_set_allocated:Secret.s_secret)
}

// -------------------------------------------------------------------

// ListSecretReply

// required uint32 total_records = 1;
inline bool ListSecretReply::has_total_records() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSecretReply::set_has_total_records() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSecretReply::clear_has_total_records() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSecretReply::clear_total_records() {
  total_records_ = 0u;
  clear_has_total_records();
}
inline ::google::protobuf::uint32 ListSecretReply::total_records() const {
  // @@protoc_insertion_point(field_get:ListSecretReply.total_records)
  return total_records_;
}
inline void ListSecretReply::set_total_records(::google::protobuf::uint32 value) {
  set_has_total_records();
  total_records_ = value;
  // @@protoc_insertion_point(field_set:ListSecretReply.total_records)
}

// required uint32 total_pages = 2;
inline bool ListSecretReply::has_total_pages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListSecretReply::set_has_total_pages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListSecretReply::clear_has_total_pages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListSecretReply::clear_total_pages() {
  total_pages_ = 0u;
  clear_has_total_pages();
}
inline ::google::protobuf::uint32 ListSecretReply::total_pages() const {
  // @@protoc_insertion_point(field_get:ListSecretReply.total_pages)
  return total_pages_;
}
inline void ListSecretReply::set_total_pages(::google::protobuf::uint32 value) {
  set_has_total_pages();
  total_pages_ = value;
  // @@protoc_insertion_point(field_set:ListSecretReply.total_pages)
}

// required uint32 limit = 3;
inline bool ListSecretReply::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListSecretReply::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListSecretReply::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListSecretReply::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 ListSecretReply::limit() const {
  // @@protoc_insertion_point(field_get:ListSecretReply.limit)
  return limit_;
}
inline void ListSecretReply::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:ListSecretReply.limit)
}

// required uint32 offset = 4;
inline bool ListSecretReply::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListSecretReply::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListSecretReply::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListSecretReply::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 ListSecretReply::offset() const {
  // @@protoc_insertion_point(field_get:ListSecretReply.offset)
  return offset_;
}
inline void ListSecretReply::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:ListSecretReply.offset)
}

// repeated .Secret secret = 5 [(.nanopb) = {
inline int ListSecretReply::secret_size() const {
  return secret_.size();
}
inline void ListSecretReply::clear_secret() {
  secret_.Clear();
}
inline const ::Secret& ListSecretReply::secret(int index) const {
  // @@protoc_insertion_point(field_get:ListSecretReply.secret)
  return secret_.Get(index);
}
inline ::Secret* ListSecretReply::mutable_secret(int index) {
  // @@protoc_insertion_point(field_mutable:ListSecretReply.secret)
  return secret_.Mutable(index);
}
inline ::Secret* ListSecretReply::add_secret() {
  // @@protoc_insertion_point(field_add:ListSecretReply.secret)
  return secret_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Secret >*
ListSecretReply::mutable_secret() {
  // @@protoc_insertion_point(field_mutable_list:ListSecretReply.secret)
  return &secret_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Secret >&
ListSecretReply::secret() const {
  // @@protoc_insertion_point(field_list:ListSecretReply.secret)
  return secret_;
}

// -------------------------------------------------------------------

// RemoveCoinRequest

// required string password = 1;
inline bool RemoveCoinRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveCoinRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveCoinRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveCoinRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& RemoveCoinRequest::password() const {
  // @@protoc_insertion_point(field_get:RemoveCoinRequest.password)
  return password_.GetNoArena();
}
inline void RemoveCoinRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RemoveCoinRequest.password)
}
#if LANG_CXX11
inline void RemoveCoinRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RemoveCoinRequest.password)
}
#endif
inline void RemoveCoinRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RemoveCoinRequest.password)
}
inline void RemoveCoinRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RemoveCoinRequest.password)
}
inline ::std::string* RemoveCoinRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:RemoveCoinRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemoveCoinRequest::release_password() {
  // @@protoc_insertion_point(field_release:RemoveCoinRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoveCoinRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:RemoveCoinRequest.password)
}

// required uint32 type = 2;
inline bool RemoveCoinRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveCoinRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveCoinRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveCoinRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 RemoveCoinRequest::type() const {
  // @@protoc_insertion_point(field_get:RemoveCoinRequest.type)
  return type_;
}
inline void RemoveCoinRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:RemoveCoinRequest.type)
}

// -------------------------------------------------------------------

// RemoveCoinReply

// -------------------------------------------------------------------

// DeleteSecretRequest

// required string password = 1;
inline bool DeleteSecretRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteSecretRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteSecretRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteSecretRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& DeleteSecretRequest::password() const {
  // @@protoc_insertion_point(field_get:DeleteSecretRequest.password)
  return password_.GetNoArena();
}
inline void DeleteSecretRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeleteSecretRequest.password)
}
#if LANG_CXX11
inline void DeleteSecretRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeleteSecretRequest.password)
}
#endif
inline void DeleteSecretRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeleteSecretRequest.password)
}
inline void DeleteSecretRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeleteSecretRequest.password)
}
inline ::std::string* DeleteSecretRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:DeleteSecretRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteSecretRequest::release_password() {
  // @@protoc_insertion_point(field_release:DeleteSecretRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteSecretRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:DeleteSecretRequest.password)
}

// required uint32 type = 2;
inline bool DeleteSecretRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteSecretRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteSecretRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteSecretRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 DeleteSecretRequest::type() const {
  // @@protoc_insertion_point(field_get:DeleteSecretRequest.type)
  return type_;
}
inline void DeleteSecretRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:DeleteSecretRequest.type)
}

// required uint32 idx = 3;
inline bool DeleteSecretRequest::has_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteSecretRequest::set_has_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteSecretRequest::clear_has_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteSecretRequest::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 DeleteSecretRequest::idx() const {
  // @@protoc_insertion_point(field_get:DeleteSecretRequest.idx)
  return idx_;
}
inline void DeleteSecretRequest::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:DeleteSecretRequest.idx)
}

// -------------------------------------------------------------------

// DeleteSecretReply

// -------------------------------------------------------------------

// DeleteAddressRequest

// required string password = 1;
inline bool DeleteAddressRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteAddressRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteAddressRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteAddressRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& DeleteAddressRequest::password() const {
  // @@protoc_insertion_point(field_get:DeleteAddressRequest.password)
  return password_.GetNoArena();
}
inline void DeleteAddressRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeleteAddressRequest.password)
}
#if LANG_CXX11
inline void DeleteAddressRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DeleteAddressRequest.password)
}
#endif
inline void DeleteAddressRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeleteAddressRequest.password)
}
inline void DeleteAddressRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeleteAddressRequest.password)
}
inline ::std::string* DeleteAddressRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:DeleteAddressRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteAddressRequest::release_password() {
  // @@protoc_insertion_point(field_release:DeleteAddressRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteAddressRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:DeleteAddressRequest.password)
}

// required uint32 type = 2;
inline bool DeleteAddressRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteAddressRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteAddressRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteAddressRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 DeleteAddressRequest::type() const {
  // @@protoc_insertion_point(field_get:DeleteAddressRequest.type)
  return type_;
}
inline void DeleteAddressRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:DeleteAddressRequest.type)
}

// required uint32 idx = 3;
inline bool DeleteAddressRequest::has_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteAddressRequest::set_has_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteAddressRequest::clear_has_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteAddressRequest::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 DeleteAddressRequest::idx() const {
  // @@protoc_insertion_point(field_get:DeleteAddressRequest.idx)
  return idx_;
}
inline void DeleteAddressRequest::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:DeleteAddressRequest.idx)
}

// -------------------------------------------------------------------

// DeleteAddressReply

// -------------------------------------------------------------------

// ResetRequest

// required string password = 1;
inline bool ResetRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& ResetRequest::password() const {
  // @@protoc_insertion_point(field_get:ResetRequest.password)
  return password_.GetNoArena();
}
inline void ResetRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ResetRequest.password)
}
#if LANG_CXX11
inline void ResetRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ResetRequest.password)
}
#endif
inline void ResetRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ResetRequest.password)
}
inline void ResetRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ResetRequest.password)
}
inline ::std::string* ResetRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:ResetRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResetRequest::release_password() {
  // @@protoc_insertion_point(field_release:ResetRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResetRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:ResetRequest.password)
}

// -------------------------------------------------------------------

// ResetReply

// -------------------------------------------------------------------

// DispMsgRequest

// required bytes title = 1;
inline bool DispMsgRequest::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DispMsgRequest::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DispMsgRequest::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DispMsgRequest::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_title();
}
inline const ::std::string& DispMsgRequest::title() const {
  // @@protoc_insertion_point(field_get:DispMsgRequest.title)
  return title_.GetNoArena();
}
inline void DispMsgRequest::set_title(const ::std::string& value) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DispMsgRequest.title)
}
#if LANG_CXX11
inline void DispMsgRequest::set_title(::std::string&& value) {
  set_has_title();
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DispMsgRequest.title)
}
#endif
inline void DispMsgRequest::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DispMsgRequest.title)
}
inline void DispMsgRequest::set_title(const void* value, size_t size) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DispMsgRequest.title)
}
inline ::std::string* DispMsgRequest::mutable_title() {
  set_has_title();
  // @@protoc_insertion_point(field_mutable:DispMsgRequest.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DispMsgRequest::release_title() {
  // @@protoc_insertion_point(field_release:DispMsgRequest.title)
  clear_has_title();
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DispMsgRequest::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    set_has_title();
  } else {
    clear_has_title();
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:DispMsgRequest.title)
}

// required bytes content = 2;
inline bool DispMsgRequest::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DispMsgRequest::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DispMsgRequest::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DispMsgRequest::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& DispMsgRequest::content() const {
  // @@protoc_insertion_point(field_get:DispMsgRequest.content)
  return content_.GetNoArena();
}
inline void DispMsgRequest::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DispMsgRequest.content)
}
#if LANG_CXX11
inline void DispMsgRequest::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DispMsgRequest.content)
}
#endif
inline void DispMsgRequest::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DispMsgRequest.content)
}
inline void DispMsgRequest::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DispMsgRequest.content)
}
inline ::std::string* DispMsgRequest::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:DispMsgRequest.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DispMsgRequest::release_content() {
  // @@protoc_insertion_point(field_release:DispMsgRequest.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DispMsgRequest::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:DispMsgRequest.content)
}

// required bytes icon = 3;
inline bool DispMsgRequest::has_icon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DispMsgRequest::set_has_icon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DispMsgRequest::clear_has_icon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DispMsgRequest::clear_icon() {
  icon_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_icon();
}
inline const ::std::string& DispMsgRequest::icon() const {
  // @@protoc_insertion_point(field_get:DispMsgRequest.icon)
  return icon_.GetNoArena();
}
inline void DispMsgRequest::set_icon(const ::std::string& value) {
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DispMsgRequest.icon)
}
#if LANG_CXX11
inline void DispMsgRequest::set_icon(::std::string&& value) {
  set_has_icon();
  icon_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DispMsgRequest.icon)
}
#endif
inline void DispMsgRequest::set_icon(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DispMsgRequest.icon)
}
inline void DispMsgRequest::set_icon(const void* value, size_t size) {
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DispMsgRequest.icon)
}
inline ::std::string* DispMsgRequest::mutable_icon() {
  set_has_icon();
  // @@protoc_insertion_point(field_mutable:DispMsgRequest.icon)
  return icon_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DispMsgRequest::release_icon() {
  // @@protoc_insertion_point(field_release:DispMsgRequest.icon)
  clear_has_icon();
  return icon_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DispMsgRequest::set_allocated_icon(::std::string* icon) {
  if (icon != NULL) {
    set_has_icon();
  } else {
    clear_has_icon();
  }
  icon_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), icon);
  // @@protoc_insertion_point(field_set_allocated:DispMsgRequest.icon)
}

// -------------------------------------------------------------------

// DispMsgReply

// required bool result = 1;
inline bool DispMsgReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DispMsgReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DispMsgReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DispMsgReply::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool DispMsgReply::result() const {
  // @@protoc_insertion_point(field_get:DispMsgReply.result)
  return result_;
}
inline void DispMsgReply::set_result(bool value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:DispMsgReply.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::IceboxMessage_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IceboxMessage_Type>() {
  return ::IceboxMessage_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_icebox_2eproto__INCLUDED
